/**
\page message_queue_prosa The message_queue class in context.

\section intro Introduction
It has been found that message passing is one of the safest primitives for
organising code in more than one thread or process. The class
gott::thread::message_queue provides a convenient C++ primitive for passing
messages in process, that is between threads. Its size can be limited to prevent
waste of memory, it can be opened/closed and it optionally supports priority
handling.

\section pcp Producer-consumer pattern
\subsection pcp_1_1 One producer, one consumer
Imagine you have two threads. One thread (the producer) does nothing but wait
for some resource and extract elements from it. The other thread (the consumer)
shall do something with the elements. What do we need?
-# Some way to pass elements from the producer to the consumer.
-# Some way for the producer to tell the consumer that it has quit.
As a further restriction, the program shall be portable across very different
kinds of systems. 

So lets define an example: The programm shall read small positive integers from
a file and the program shall double them and print them out. Consumer and
producer share a variable:
\code
gott::thread::message_queue<int> element_transfer;
\endcode

\attention
There is no need for critical sections or semaphores or anything of the kind in
order to use gott::thread::message_queue. It is safe to access it directly. You
need to program carefully to prevent deadlocks though.

Then, the producer looks something like this:
\code
std::ifstream infile("numbers.txt");
int num;
while (infile >> num) {
  if (num < 0) break;
  element_transfer.push(num);
}
element_transfer.push(-1);
\endcode
Negative numbers mark the end-of-sequence and can be compared with a special 
"quit message".

And the consumer:
\code
int num;
while ((num = element_transfer.pop()) >= 0)
  std::cout << (num * 2) << std::endl;
\endcode
The consumer uses std::cout directly but as it is the only thread to use it, 
that's safe.

Alternatively, you can write the consumer like this:
\code
using namespace boost::lambda;
element_transfer.wait_for_all(std::cout << _1 << '\n', _1 >= 0);
\endcode
There is a difference in behaviour: The first consumer flushes std::cout after
every element, the second does not because std::endl can't be conveniently
passed via Boost.Lambda - it IS possible though.

\subsection pcp_1_m One producer, multiple consumers
If there is more than one consumer, we have to take care of letting them all end
if there is nothing to get any more. In the example of \ref pcp_1_1 "the last section", we just sent a simple -1 and the consumer removed it and quit. This
mechanism is fine to quit one consumer, but if more than one consumer has to
quit, we need different logics. We could simply send as many quit messages as
there are consumers. We could use a guarded variable (volatile doesn't suffice)
marking whether the producer has quit. Or we could simply not remove the quit
message. Or even each consumer could repost a quit message. The last two have
the advantage of being scalable and the producer need not be changed. So this
is how a consumer could look like:
\code
struct helper_t {
  int &num;
  helper_t(int &num) : num(num) {}
  bool operator() (int value) const {
    num = value;
    return value >= 0;
  }
};
int num;
helper_t helper(num);
while (element_transfer.pop_if(helper))
  std::cout << (num * 2) << std::endl;
\endcode
\note
All methods of gott::thread::message_queue taking functors as arguments take
them by value.

\subsection pcp_n_1 Multiple producers, one consumer
\subsection pcp_n_m Multiple producers, multiple consumers
*/
