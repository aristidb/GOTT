/**
\page message_queue_prosa The message_queue class in context.

\section intro Introduction
It has been found that message passing is one of the safest primitives for
organising code in more than one thread or process. The class
gott::thread::message_queue provides a convenient C++ primitive for passing
messages in process, that is between threads. Its size can be limited to prevent
waste of memory, it can be opened/closed and it optionally supports priority
handling.

\section pcp Producer-consumer pattern
\subsection pcp_1_1 One producer, one consumer
Imagine you have two threads. One thread (the producer) does nothing but wait
for some resource and extract elements from it. The other thread (the consumer)
shall do something with the elements. What do we need?
-# Some way to pass elements from the producer to the consumer.
-# Some way for the producer to tell the consumer that it has quit.
As a further restriction, the program shall be portable across very different
kinds of systems. 

So lets define an example: The programm shall read small positive integers from
a file and the program shall double them and print them out. Consumer and
producer share a variable:
\code
gott::thread::message_queue<int> element_transfer;
\endcode

\attention
There is no need for critical sections or semaphores or anything of the kind in
order to use gott::thread::message_queue. It is safe to access it directly. You
need to program carefully to prevent deadlocks though.

Then, the producer looks something like this:
\code
std::ifstream infile("numbers.txt");
int num;
while (infile >> num) {
  if (num < 0) break;
  element_transfer.push(num);
}
element_transfer.push(-1);
\endcode
Negative numbers mark the end-of-sequence and can be compared with a special 
"quit message".

And the consumer:
\code
int num;
while ((num = element_transfer.pop()) >= 0)
  std::cout << (num * 2) << std::endl;
\endcode
The consumer uses std::cout directly but as it is the only thread to use it, 
that's safe.

Alternatively, you can write the consumer like this:
\code
using namespace boost::lambda;
element_transfer.wait_for_all(std::cout << _1 << '\n', _1 >= 0);
\endcode
There is a difference in behaviour: The first consumer flushes std::cout after
every element, the second does not because std::endl can't be conveniently
passed via Boost.Lambda - it IS possible though.

\subsection pcp_1_m One producer, multiple consumers
If there is more than one consumer, we have to take care of letting them all end
if there is nothing to get any more. In the example of \ref pcp_1_1 "the last section", we just sent a simple -1 and the consumer removed it and quit. This
mechanism is fine to quit one consumer, but if more than one consumer has to
quit, we need different logics. We could simply send as many quit messages as
there are consumers. We could use a guarded variable (volatile doesn't suffice)
marking whether the producer has quit. Or we could simply not remove the quit
message. Or even each consumer could repost a quit message. The last two have
the advantage of being scalable and the producer need not be changed. So this
is how a consumer could look like:
\code
struct helper_t {
  int &num;
  helper_t(int &num) : num(num) {}
  bool operator() (int value) const {
    num = value;
    return value >= 0;
  }
};
int num;
helper_t helper(num);
while (element_transfer.pop_if(helper))
  print_safely(num * 2);
\endcode
\note
All methods of gott::thread::message_queue taking functors as arguments take
them by value.
\attention
The above code uses a custom function print_safely to print a number on 
std::cout because using it directly would <b>not</b> be thread-safe.

\subsection pcp_n_1 Multiple producers, one consumer
If there is more than one producer, a whole new problem arises: When to quit,
actually? When a "main producer" quits? When all producers quit? Some other
event?

When the program shall quit on some other system event, the situation is easy:
Get the event and push a quit message.

When the program shall end as soon as a special "main producer" quits, the
situation is easy for the consumers: they can behave as if there were only
one producer and just quit as soon as they see a quit message - the quit message
should not be removed though. Still, there are other producers that need to
quit. As the quit message is never removed, it suffices to peek and check for
a quit message before waiting on the resource. Something like this:
\code
int num;
for (;;) {
  boost::optional<int> possible_quit = element_transfer.peek_noblock();
  if (possible_quit && *possible_quit < 0)
    break;
  if (infile >> num)
    element_transfer.push(num);
}
\endcode

??? Multiple consumers (nicest solution) ???

\subsection pcp_n_m Multiple producers, multiple consumers

\subsection pcp_mem Any number of producers, NO consumers
If there is no consumer for some reason but there are producers that happily
add elements to the message queue, there is the risk of high amounts of memory
to be wasted! But (who guessed it?) gott::thread::message_queue has mechanisms
for dealing with this problem. The first ist to simply limit the size of the
queue, like this (this might be also useful in order to reduce memory 
consumption):
\code
gott::thread::message_queue<int, 50> sized_transfer;
\endcode

In some situations, you need to take care of the size because the program could
dead-lock when the size is estimated to low.  If you can't do this, there is
another solution: Just close the message queue! Shut its doors, that's possible.
For example, the following code is a nice dead-lock:
\code
gott::thread::message_queue<int> q;
q.push(4); // fine
q.close();
q.push(5); // will never return
\endcode

When there is no more consumer, just close the queue and the system's memory is
safe. Of course, it can be opened again:
\code
q.open();
assert(!q.closed());
\endcode

And it can even be constructed in closed state (opened is standard):
\code
gott::thread::message_queue<int> closed_q(false);
\endcode

\section prio Dealing with priorities
By default, gott::thread::message_queue just deals with messages like a queue
is supposed to: First come, first serve. If, for some reason, you want messages
to be ordered, gott::thread::message_queue needs a functor to do so. The functor
shall take two arguments and return a boolean value whether the left-hand-side
argument's priority is lower than the right-hand-side argument's priority (true)
or vice versa (false). So this example prints "1.5 1" (you <i>could</i> use 
std::priority_queue for that, but hey we're talking message_queue):
\code
gott::thread::message_queue<double, 0, std::less<double> > ordered_double;
ordered_double.push(1);
ordered_double.push(1.5);
std::cout << ordered_double.pop() << ' ';
std::cout << ordered_double.pop() << std::endl;
\endcode
\note
The 0 (zero) specifies that the queue has unlimited size, which is the default.
Any other number would imply an enforced maximum size.
*/
