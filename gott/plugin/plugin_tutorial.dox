/* ***** BEGIN LICENSE BLOCK *****
 * Version: MPL 1.1/GPL 2.0/LGPL 2.1
 *
 * The contents of this file are subject to the Mozilla Public License Version
 * 1.1 (the "License"); you may not use this file except in compliance with
 * the License. You may obtain a copy of the License at
 * http://www.mozilla.org/MPL/
 *
 * Software distributed under the License is distributed on an "AS IS" basis,
 * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
 * for the specific language governing rights and limitations under the
 * License.
 *
 * The Original Code is A Plugin / Loadable Module Engine.
 *
 * The Initial Developer of the Original Code is
 * Aristid Breitkreuz (aribrei@arcor.de).
 * Portions created by the Initial Developer are Copyright (C) 2006
 * the Initial Developer. All Rights Reserved.
 *
 * Contributor(s):
 *  Aristid Breitkreuz (aribrei@arcor.de)
 *
 * Alternatively, the contents of this file may be used under the terms of
 * either the GNU General Public License Version 2 or later (the "GPL"), or
 * the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
 * in which case the provisions of the GPL or the LGPL are applicable instead
 * of those above. If you wish to allow use of your version of this file only
 * under the terms of either the GPL or the LGPL, and not to allow others to
 * use your version of this file under the terms of the MPL, indicate your
 * decision by deleting the provisions above and replace them with the notice
 * and other provisions required by the GPL or the LGPL. If you do not delete
 * the provisions above, a recipient may use your version of this file under
 * the terms of any one of the MPL, the GPL or the LGPL.
 *
 * ***** END LICENSE BLOCK ***** */

/**
\page plugin_tutorial A tutorial for GOTT plugins.

\section intro Introduction

Plugins are a wonderful method for creating dynamic, extensible applications.
GOTT plugins strive for maximum flexibility and usability. You need basically
two things for a functional plugin: a dynamic library (also called shared object
or library under some circumstances) and accompanying metadata.

\section quickstart Quick start / Hello world

Let's do a "Hello world" with GOTT plugins. First we need an interface:
\code
// simple_action.hpp
#ifndef SIMPLE_ACTION_HPP
#define SIMPLE_ACTION_HPP
#include <gott/plugin/plugin_base.hpp>

namespace my {
//interface-id: my::simple_action (just a QID)
class GOTT_EXPORT simple_action : public gott::plugin::plugin_base {
public:
  virtual void do_it() = 0;
  virtual ~simple_action();
};
}
#endif

// simple_action.cpp
#include "simple_action.hpp"

my::simple_action::~simple_action() {} // for vtable/typeinfo
\endcode
We <b>have to</b> put this interface into a shared library.

Then, let's create a simple application that links to the generated shared
library above:
\code
#include "simple_application.hpp"
#include <gott/plugin.hpp>

using namespace gott::plugin;

int main() {
  // Find the first plugin which supports the interface and load it.
  plugin_handle<my::simple_action> handle(
    find_plugin_metadata(tags::interface = "my::simple_action"));
  handle->do_it();
}
\endcode

Now we have an application that can use plugins but no plugin by itself. We 
shall define this one now:
\code
// my_plugin.cpp
#include "simple_application.hpp"
#include <gott/plugin.hpp>
#include <iostream>

namespace {
class hello : public my::simple_action {
public:
  void do_it() {
    std::cout << "Hello world!" << std::endl;
  }
};
}

GOTT_PLUGIN_MAKE_BUILDER_SIMPLE(hello, the_plugin)
\endcode
Put this into a shared library of its own, suppose it is saved to
/home/max/hello.so, then we need to add the following metadata to
module_metadata.tdl:
\verbatim
module-id my::hello::container
module-type dynamic-native # it's a shared library
file-path /home/max/hello.so
\endverbatim

And we need to add the following lines to plugin_metadata.tdl:
\verbatim
plugin-id my::hello::plugin
has-interface my::simple_action
enclosing-module my::hello::container
symbol the_plugin
\endverbatim

Hope you can figure it out. You should see something like this on your screen:
<verbatim>
Hello world!
</verbatim>

\subsection more_action But I want more action!

OK, we'll do that. You want more action? I'll give you more action<b>s</b>!
First, we change the application like this:
\code
#include "simple_application.hpp"
#include <gott/plugin.hpp>

using namespace gott::plugin;

namespace {
void run_action(plugin_metadata const &which) {
  plugin_handle<my::simple_action> handle(which);
  handle->do_it();
  handle->do_it();
}
}

int main() {
  enumerate_plugin_metadata(
    tags::interface = "my::simple_action",
    tags::callback = &run_action);
}
\endcode

When you run this, the output should be:
<verbatim>
Hello world!
Hello world!
</verbatim>

But we wanted more action, or at least something more interesting. We shall fix
that:
\code
#include "simple_action.hpp"
#include <gott/plugin.hpp>
#include <iostream>
#include <cstdlib>
#include <ctime>

namespace {
class random : public my::simple_action {
  random() {
    std::srand(std::time(0));
  }

  void do_it() {
    std::cout << std::rand() << std::endl;
  }
};
}

GOTT_PLUGIN_MAKE_BUILDER_SIMPLE(random, the_second_plugin)
\endcode
Add this to the same shared library as the first plugin (you may add it to a
separate, too). Then, add the following to plugin_registry.tdl:

<verbatim>
plugin-id my::random::plugin
enclosing-module my::hello::container
has-interface my::simple_action
symbol the_second_plugin
</verbatim>

Now, run and be astonished by something like this:
<verbatim>
Hello world!
Hello world!
746455
375483
</verbatim>
 */
