// vim:ts=2:sw=2:expandtab:autoindent:filetype=cpp:
/* ***** BEGIN LICENSE BLOCK *****
 * Version: MPL 1.1/GPL 2.0/LGPL 2.1
 *
 * The contents of this file are subject to the Mozilla Public License Version
 * 1.1 (the "License"); you may not use this file except in compliance with
 * the License. You may obtain a copy of the License at
 * http://www.mozilla.org/MPL/
 *
 * Software distributed under the License is distributed on an "AS IS" basis,
 * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
 * for the specific language governing rights and limitations under the
 * License.
 *
 * The Original Code is A Non-immediate Graphics Library.
 *
 * The Initial Developer of the Original Code is
 * Andreas Pokorny (andreas.pokorny@gmail.com).
 * Portions created by the Initial Developer are Copyright (C) 2005
 * the Initial Developer. All Rights Reserved.
 *
 * Contributor(s):
 *  Andreas Pokorny (andreas.pokorny@gmail.com)
 *
 * Alternatively, the contents of this file may be used under the terms of
 * either the GNU General Public License Version 2 or later (the "GPL"), or
 * the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
 * in which case the provisions of the GPL or the LGPL are applicable instead
 * of those above. If you wish to allow use of your version of this file only
 * under the terms of either the GPL or the LGPL, and not to allow others to
 * use your version of this file under the terms of the MPL, indicate your
 * decision by deleting the provisions above and replace them with the notice
 * and other provisions required by the GPL or the LGPL. If you do not delete
 * the provisions above, a recipient may use your version of this file under
 * the terms of any one of the MPL, the GPL or the LGPL.
 *
 * ***** END LICENSE BLOCK ***** */

/**
  \page graphics_pipeline Graphics Drawing System


  \section graphics_pipeline_comment Comment

  First of all, before we start: 
  I am not yet sure how the widgets provide their "view" parts. One 
  possiblitty would be to let the window have a complete tree of all 
  combined "view" parts of 
  all widgets. Then the widgets degrade to their behavioural aspects
  refering to their graphical representation using pointers into the 
  complete tree. 

  Or one has the common tree of widgets, each of them having a "view"
  part to explore. 
  
  "Right now i am in favor of the first variant." (6.10.2006 a.p.)
 
  \section graphics_pipeline_intro Intro

  This document describes the set of pipeline classes, which are responsible
  to display the different widgets and windows on screen. Widgets never draw
  themselves by using some kind of API, neither do the graphics::object 
  draw themselves. The pipeline could be implemented as:
  \code
  void mystupidpipeline::update_display( region const& ) 
  {
    for_each( 
      graphics_objects.tree_df_begin()
      , graphics_objects.tree_df_end()
      , bind(&mystupidpipeline::draw_object,this) 
      ); 
  }
  void mystupidpipeline::draw_object( graphics::object & object )
  {
    // .. dispatch type of object and draw or skip object
  }
  \endcode

  Better pipelines are able to look at subtrees as a whole and cache drawing results
  and may do whatever makes drawing faster. For example Antigrain/* pipelines might 
  have several instantiated rasterizers with different span generators and path 
  transformators, and thus will be able to pick one depending on the path of graphics::objects
  traversed. 
 
  We do not define the inner workings of a pipeline, the inner workings of a pipeline
  is defined by the render method used. So OpenGL defines the GL pipeline,
  Antigrain define the Antigrain pipeline. These two pipeliens will have completely diverging
  implementations, since Antigrain thinks in paths and scanlines while GL thinks in 
  triangles, shaders, textures and buffers. ("I also belive that we will have different
  GL pipelines, depending on the extensions supported. E.g. one with GL-1.5 features and 
  one with GL-2.1 features.. ")

  The results of the pipelines should just match as far as possible.

  \section graphics_pipeline_embedding Embedding the pipeline into the System
  Pipeline is connected to a window using a factory class 
  which helps setting up the details of the window
  and provides a pipeline object. 
  e.g.: Antigrain/X11 requires a visual that matches the pixelformat
  of the antigrain pipeline and must try to make use of mit-XShm, 
  while Opengl/X11 needs to find a visual that provides OpenGL hardware
  acceleration. But OpenGL/FB will not think about visuals at all.  

  So this factory class, which defines a connection between window and 
  pipeline requires a unique interface for every ui_context type, which 
  will be implemented for every pipeline implementation.

  \code 
  class pipeline
  {
    public:
      // pipeline domain, is explained below
      qid domain_of_pipeline();

      // pipelines should be able to receive all ui related events
      // so X11 or all? pipelines probably define methods like:
      void update_display( region const& ); ///< pipeline should update these screen regions, because x11 made them reappear
      void resize( region const& ); ///< pipeline should redraw mostly everything becaue the window size changed..

      // every pipeline will need to know if widgets changed their
      // graphical representation
      void invalidate( graphics::object * );
      // or maybe
      void invalidate( qid_or_graphics_object_path * path_to_invalid_object );


  };
  \endcode 

  \note Maybe we should make the pipeline a kind of "owner" or controller of the 
  graphics::objects. That way we could allow the pipelines to attach information
  to the graphics::object tree, e.g. for caches or precalculations, like triangulation.


  \section graphics_themes_outline Themes and graphics::object

  A graphics::object is a node class, which provides means to iterate on a tree. 
  The tree is constructed by the theme loader. Our widget types do have a qid that 
  name the graphical representation of each widget. The theme loader will search 
  for that qid in different places using the domain information provided by the 
  pipeline object. That domain define the name of the draw model. We might have 
  names like:
   - gott::vector_graphics: antigrain cairo opengl directGraphics
   - gott::text_mode: curses conio vt100.. 
   - gott::3d_vector_graphics: variants of the vector_graphics pipelines with hardware 
      acceleration that support 3D eyecandy, that implies that 3D information is stored 
      in graphics::object, but the display still happens on a 2D or pesudo 3D screen. 
   - gott::ajax: restrictive variants of gott::vector_graphics piplines, maybe not required
      as special domain name
   - gott::exploreable_3d_graphis: somtime around 2010 we will implement that beast :), as 
      soon as better input devices exist

  The theme loader now knows which themes can be used at all. Gott will provide a 
  working set of graphics::object subtrees for every default widget. The other
  themes found inside the system will override the subtrees of Gott. The application
  may also provide additional replacement subtrees. Furthermore the applcation
  or themes might even provide different widget names/qids, which have their
  own unique graphics representation. Finally the user of gott has the option to install
  themes in his home directory. For example she could define color themes which 
  redefine the default colors of all his gott application, be redefining the qids
  referencing default colors. 

  \section graphics_objects_discussion Discussion about graphics objects tree 
  We now have to define the layout of our graphics object tree. There are several 
  possiblities for each of the render model domains. Suggestions are welcome. 

  \subsection graphics_objects_discussion_vector First two cents

  \code
  class object
  {
    boost::ptr_vector<object> childs;
    typedef std::vector<int> path; // path using indices .. hmm
    Xany pipeline_data;
  };
  \endcode

  \subsection graphics_objects_discussion_ur_turn Your turn!


  \section event_forwarding Events forwarded to widgets

  The pipeline must know the position of each leaf graphic::object on screen. 
  To be able to forward events to the behavior part of the widget. These things
  have to be evaluated inside the pipeline, because each pipeline API has 
  different means to fulfill that requirement.

  So we need a bidirectional connection between graphics::object and the behavior
  of the widget. 


 */
