// vim:ts=2:sw=2:expandtab:autoindent:filetype=cpp:
/* ***** BEGIN LICENSE BLOCK *****
 * Version: MPL 1.1/GPL 2.0/LGPL 2.1
 *
 * The contents of this file are subject to the Mozilla Public License Version
 * 1.1 (the "License"); you may not use this file except in compliance with
 * the License. You may obtain a copy of the License at
 * http://www.mozilla.org/MPL/
 *
 * Software distributed under the License is distributed on an "AS IS" basis,
 * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
 * for the specific language governing rights and limitations under the
 * License.
 *
 * The Original Code is A Non-immediate Graphics Library.
 *
 * The Initial Developer of the Original Code is
 * Andreas Pokorny (andreas.pokorny@gmail.com).
 * Portions created by the Initial Developer are Copyright (C) 2005
 * the Initial Developer. All Rights Reserved.
 *
 * Contributor(s):
 *  Andreas Pokorny (andreas.pokorny@gmail.com)
 *
 * Alternatively, the contents of this file may be used under the terms of
 * either the GNU General Public License Version 2 or later (the "GPL"), or
 * the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
 * in which case the provisions of the GPL or the LGPL are applicable instead
 * of those above. If you wish to allow use of your version of this file only
 * under the terms of either the GPL or the LGPL, and not to allow others to
 * use your version of this file under the terms of the MPL, indicate your
 * decision by deleting the provisions above and replace them with the notice
 * and other provisions required by the GPL or the LGPL. If you do not delete
 * the provisions above, a recipient may use your version of this file under
 * the terms of any one of the MPL, the GPL or the LGPL.
 *
 * ***** END LICENSE BLOCK ***** */

/**
  \page graphics_pipeline Graphics Drawing System


  \section graphics_pipeline_comment Comment

  1. First of all, before we start: 
    I am not yet sure how the widgets provide their "view" parts. One 
    possibility would be to let the window have a complete tree of all 
    combined "view" parts, so called graphics::objects, of 
    all widgets. Then the widgets degrade to their behavior aspects while
    refering to their graphical representation using pointers into the 
    complete tree. 

    Or one has the common tree of widgets, each of them having a "view"
    part to explore.
  
    "Right now i am in favor of the first variant." (6.10.2006 a.p.)

  2. Rename Pipeline: This might be misleading, maybe call it "drawer" or "renderer"

 
  \section graphics_pipeline_intro Intro

  This document describes the concept of the pipeline class, which is responsible
  to display the different widgets and windows on screen. Widgets never draw
  themselves by using some kind of API, neither do the graphics::object 
  draw themselves. 

  This is the current planing state of the the pipeline:

  \code 
  concept pipeline
  {
    public:
      // pipeline domain, is explained below
      qid domain_of_pipeline();

      // pipelines should be able to receive all ui related events
      // so X11 or all? pipelines probably define methods like:
      void update_display( region const& ); ///< pipeline should update these screen regions, because x11 made them reappear
      void resize( region const& ); ///< pipeline should redraw mostly everything becaue the window size changed..

      // every pipeline will need to know if widgets changed their
      // graphical representation
      void invalidate( graphics::object * );
      // or maybe
      void invalidate( qid_or_graphics_object_path * path_to_invalid_object );
  };
  \endcode 

  That domain defines the name of the draw model. We might have 
  names like:
   - "gott::vector_graphics": antigrain cairo opengl directGraphics
   - "gott::text_mode": curses conio vt100.. 
   - "gott::3d_vector_graphics": variants of the vector_graphics pipelines with hardware 
      acceleration that support 3D eyecandy, that implies that 3D information is stored 
      in graphics::object, but the display still happens on a 2D or pesudo 3D screen. 
   - "gott::ajax": restrictive variants of gott::vector_graphics piplines, maybe not required
      as special domain name
   - "gott::exploreable_3d_graphics": sometime around 2010 we will implement that beast :), as 
      soon as better input devices exist


  Drawing might happen inside update_display, or might be triggered by a different event,
  this all depends on the environment the pipeline was written for. 

  The update_display of a pipeline could be implemented as:
  \code
  void mystupidpipeline::update_display( region const& ) 
  {
    for_each( 
      graphics_objects.tree_df_begin()
      , graphics_objects.tree_df_end()
      , bind(&mystupidpipeline::draw_object,this) 
      ); 
  }
  void mystupidpipeline::draw_object( graphics::object & object )
  {
    // .. dispatch type of object and draw or skip object
  }
  \endcode

  Better pipelines should look at subtrees as a whole and cache drawing results
  and should do whatever makes drawing faster. For example an Antigrain/* pipeline might 
  have several instantiated rasterizers with different span generators and path 
  transformators, would pick one depending on the path of graphics::objects
  traversed. 
 
  We do not define the inner operation of a pipeline, the inner operation of a pipeline
  is defined by the render method used. So OpenGL defines the GL pipeline,
  Antigrain define the Antigrain pipeline. These two pipeliens will have completely diverging
  implementations, since Antigrain thinks in paths and scanlines while GL thinks in 
  triangles, shaders, textures and buffers. ("I also belive that we will have different
  GL pipelines, depending on the extensions supported, luckily we have to the power to decide 
  during runtime which pipeline fits best")

  The results of the pipelines should just match as far as possible.

  \section graphics_pipeline_embedding Embedding the pipeline into the System
  Pipeline is connected to a window using a factory class 
  which helps setting up the details of the window
  and provides a pipeline object. 

  Example Use cases:
   - Antigrain/X11 requires a visual that matches the pixelformat
     of the antigrain pipeline and must try to make use of mit-XShm, 
   - Opengl/X11 needs to find a visual that provides OpenGL hardware
     acceleration and the Window to construct an opengl context.
   - OpenGL/FB might not have any requirements at all.  

  So this factory class, which defines a connection between window and 
  pipeline requires a unique interface for every ui_context type, which 
  will be implemented for every pipeline implementation.

  Eg. for X11 pipelines
  \code
  concept X11Pipeline : pipeline
  { 
    concept X11PipelineFactory  
    {
    public: 
      XVisual get_visual( Window x11WindowHandle, Display * displayHandle, int screen );

      pipeline* construct_pipeline( Window x11WindowHandle, Display * displayHandle );
    };
  };
  \endcode

    \note Maybe we should make the pipeline a kind of "owner" or controller of the 
  graphics::objects. That way we could allow the pipelines to attach information
  to the graphics::object tree, e.g. for caches or precalculations, like triangulation.


  \section graphics_themes_outline Themes 

  For every supported widget type, themes define a declarative 
  and/or an active part. The first part
  defines the static view of the widgets, and is assembled using the previously 
  mentioned graphics::object. While the active or dynamic aspect of a theme must be 
  able to modify the graphics::objects it defined and react on events, similar
  to the behavior aspect of widgets. 

  Every widget type has a qid that names the graphical representation of the widget. 
  The theme loader will search for that qid in different places using the domain 
  information provided by the pipeline object. It will only search in theme files
  which are defined for that domain.

  Gott will provide a working set of graphics::object subtrees, and simple dynamic theme behaviors
  for every default widget. The other
  themes found inside the system will override the subtrees and theme behaviors of Gott. 
  The application
  may also provide additional replacement subtrees. Furthermore the applcation
  or themes might even provide different widget names/qids, which have their
  own unique graphic representation. Finally the user of gott has the option to install
  themes in his home directory. For example she could define color themes which 
  redefine the default colors of all her gott application, be redefining the qids
  referencing default colors. 


  \section graphics_objects_discussion Discussion about graphics objects tree 
  We now have to define the layout of our graphics object tree. There are several 
  possiblities for each of the render model domains. Suggestions are welcome. 

  \subsection Requirements:
   - RQ1 - tree path support: It must be easy to find a child object using a path datastructure
   - RQ2 - optional reference to a widget behavior: controls the subnodes relevant for the concept of the widget
   - RQ3 - optional reference to a theme behavior: controls special subnodes defined by the theme. It seems like
      that only these graphics::objects with a reference to a widget behavior have a reference to a theme behavior.
      Furthermore it might make sense to think of the widget behavior as very generic behavior, while the theme 
      behavior is much more detailed.
   - RQ4 - grant access to child objects:
   - RQ5 - Naming support: 
      This one is a bit more complex. So lets approach this requirement from a different point
      of view. A Label widget has a text property that holds the current text, this property
      should be a text graphics::object stored inside the graphics::object subtree. To refer 
      to the graphics::object a name unique inside the subtree is required. 
      The themes which also change the dynamic aspects of widgets will require that 
      feature too. For example if a theme wants to have a blinking rectangle everytime the 
      mouse crosses a button, the dynamic aspect of the themed widget must be able to refer
      to the rectangle defined inside the graphics::objects of the button. 
   - RQ6 - Make pipeline relevant data attachable to each object node. Or only specific nodes?
   - RQ7 - object reference support:
      To allow the user or theme writers to change general aspects of themes, and maybe to reuse existing nodes it
      should be possible to refer to certain objects in the tree. E.g. one could have named color nodes. 
      At this point the tree might turn into a dag. 
 

  \subsection graphics_objects_discussion_vector First two cents

  This is a first rough design attempt based on the requirement above.

  The object base class: 
    - pipeline_data RQ6
    - path RQ1

    \code
    namespace graphics{
    class object
    {
      typedef std::vector<int> path; 

      Xany pipeline_data; //< maintained by the pipeline
      virtual ~object();
    };
    }
    \endcode
 
  The container_object: 
   - childs are stored here (RQ4)

    \code
    namespace graphics{
    class container_object : public object
     {
      boost::ptr_vector<object> childs;
    };
    }
    \endcode

  The widget_subtree class is a subtree node, which is connected to a widget and theme behavior. 
   - The class combines RQ3 and RQ2 under the assumption that both references are always required 
     at the same point in the tree
   - The widget_subtree also defines a qid namespace for its named subnodes, one could store a 
     gperf generated perfect minimal hash function inside widget_subtree during compilation time
     of the theme ( or gott respectively ), to easily access all named nodes. 

    \code
    namespace graphics{
    class widget_subtree : public container_object
    {
      ui::widget * widget;
      ui::theme::behavior * theme_behavior;

      object * get_node( qid & node_id );
    };
    }
    \endcode


  The object_reference class fullfills RQ7. 

    \code
    namespace graphics{
    class object_reference : public object
    {
      qid reference;
      object * resolved_reference;
    };
    }
    \endcode

  We could now start to define object classes that define properties provided 
  by widgets, like text, toggle states, scalar values.... 

  \subsection graphics_objects_discussion_ur_turn Your turn!


  \section event_forwarding Events forwarded to widgets

  The pipeline must know the position of each leaf graphic::object on screen. 
  To be able to forward events to the behavior part of the widget. These things
  have to be evaluated inside the pipeline, because each pipeline API has 
  different means to fulfill that requirement.

  So we need a bidirectional connection between graphics::object and the behavior
  of the widget. 

  \note Not every graphics::object has a widget. Only some nodes in the tree have 
  that kind of behavior part. ("I need a name for that behavior thing :)" )



 */
