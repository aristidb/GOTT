# ***** BEGIN LICENSE BLOCK *****
# Version: MPL 1.1/GPL 2.0/LGPL 2.1
#
# The contents of this file are subject to the Mozilla Public License Version
# 1.1 (the "License"); you may not use this file except in compliance with
# the License. You may obtain a copy of the License at
# http://www.mozilla.org/MPL/
#
# Software distributed under the License is distributed on an "AS IS" basis,
# WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
# for the specific language governing rights and limitations under the
# License.
#
# The Original Code is GOTT Build Scripts.
#
# The Initial Developer of the Original Code is
# Aristid Breitkreuz (aribrei@arcor.de).
# Portions created by the Initial Developer are Copyright (C) 2005-2006
# the Initial Developer. All Rights Reserved.
#
# Contributor(s):
#  Aristid Breitkreuz (aribrei@arcor.de)
#  Ruediger Sonderfeld <kingruedi@c-plusplus.de>
#
# Alternatively, the contents of this file may be used under the terms of
# either the GNU General Public License Version 2 or later (the "GPL"), or
# the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
# in which case the provisions of the GPL or the LGPL are applicable instead
# of those above. If you wish to allow use of your version of this file only
# under the terms of either the GPL or the LGPL, and not to allow others to
# use your version of this file under the terms of the MPL, indicate your
# decision by deleting the provisions above and replace them with the notice
# and other provisions required by the GPL or the LGPL. If you do not delete
# the provisions above, a recipient may use your version of this file under
# the terms of any one of the MPL, the GPL or the LGPL.
#
# ***** END LICENSE BLOCK *****

def AddSysOpts(env):
	dict = env.Dictionary()
	for k, v in dict.iteritems():
		if k[:4] == 'SYS_' and v == 1:
			env.Append(CPPDEFINES = ['BUILD_' + k[4:]])

def CheckLinkerAsNeeded(context):
	context.Message('Checking if linker supports --as-needed flag... ')

	lastLinkFlags = context.env['LINKFLAGS'][:]
	context.env.Append(LINKFLAGS = ['-Wl,--as-needed'])

	result = context.TryLink("int main() { }\n", '.cpp')
	if not result:
		context.env.Replace(LINKFLAGS = lastLinkFlags)
	context.Result(result)
	return result

def CheckLinkerExportDynamic(context):
	context.Message('Checking if linker supports -E flag...')

	lastLinkFlags = context.env['LINKFLAGS'][:]
	context.env.Append(LINKFLAGS = ['-Wl,-E'])

	result = context.TryLink("int main() { }\n", '.cpp')
	if not result:
		context.env.Replace(LINKFLAGS = lastLinkFlags)
	context.Result(result)
	return result

def CheckCompilerVisibility(context):
	context.Message('Checking if compiler supports visibility attributes... ')
	lastCPPDEF = context.env['CPPDEFINES'][:]
	lastCCFLAGS = context.env['CCFLAGS'][:]
	
	context.env.Append(CPPDEFINES = ['HAS_VISIBILITY'])
	context.env.Append(CCFLAGS = '-fvisibility=hidden')

	result = context.TryCompile("int global __attribute__((visibility(\"default\")));\n", '.cpp')
	if not result:
		context.env.Replace(CCFLAGS = lastCCFLAGS)
		context.env.Replace(CPPDEFINES = lastCPPDEF)
	context.Result(result)
	return result

def CheckTemplateRepo(context):
	context.Message('Checking if compiler supports -frepo...')
	lastCXXFLAGS = context.env['CCFLAGS'][:]
	lastLINKFLAGS = context.env['LINKFLAGS'][:]

	context.env.Append(CXXFLAGS = ['-frepo'])
	context.env.Append(LINKFLAGS = ['-frepo'])

	result = context.TryCompile("int var;", '.cpp')
	if not result:
		context.env.Replace(CXXFLAGS = lastCXXFLAGS)
		context.env.Replace(LINKFLAGS = lastLINKFLAGS)
	context.Result(result)
	return result

def CheckWarnings(context):
	context.Message('Checking if compiler supports gcc-style warnings... ')
	lastCCFLAGS = context.env['CCFLAGS'][:]

	context.env.Append(CCFLAGS = Split('-Wall -W')) # stripped -Werror because of libsigc++'s hide

	result = context.TryCompile("int global;\n", '.cpp')
	if not result:
		context.env.Replace(CCFLAGS = lastCCFLAGS)
	context.Result(result)
	return result

def CheckOptimization(context):
	context.Message('Checking if compiler supports gcc-style optimization levels (if necessary)... ')
	lastCCFLAGS = context.env['CCFLAGS'][:]

	if context.env['OPTIMIZATION'] == 'full':
		level = ['-O3']
	elif context.env['OPTIMIZATION'] == 'some':
		level = ['-O2']

	context.env.Append(CCFLAGS = level)
	result = context.TryLink("#ifdef __OPTIMIZE__\nint main() {}\n#endif\n", '.cpp')
	if not result:
		context.env.Replace(CCFLAGS = lastCCFLAGS)
	context.Result(result)
	return result

def CheckDebug(context):
	context.Message('Checking if compiler supports gcc-style debug flags... ')
	lastCCFLAGS = context.env['CCFLAGS'][:]
	context.env.Append(CCFLAGS = ['-g'])
	result = context.TryCompile("void func() {}\n", '.cpp')
	if not result:
		context.env.Replace(CCFLAGS = lastCCFLAGS)
	context.Result(result)
	return result

def CheckPkgConfigPkg(context, name):
	context.Message('Checking for %s... ' % name)
	result = context.TryAction('pkg-config --exists \'%s\'' % name)[0]
	context.Result(result)
	return result

def CheckBoostDateTimeCanNanosec(context):
	context.Message('Checking if Boost date_time supports nanoseconds... ')
	result = context.TryCompile(
		"#include <boost/date_time/posix_time/posix_time_types.hpp>\nint main() { boost::posix_time::nanoseconds n(1); }", '.cpp')
	if result:
		context.env.Append(CPPDEFINES = ['BOOST_DATE_TIME_HAS_NANOSEC'])
	context.Result(result)
	return result

print 'Configuration...'
Import('env')
tests =	{
	'LinkerAsNeeded': CheckLinkerAsNeeded,
	'LinkerExportDynamic': CheckLinkerExportDynamic,
	'CompilerVisibility': CheckCompilerVisibility,
	'Warnings': CheckWarnings,
	'Optimization': CheckOptimization,
	'Debug': CheckDebug,
	'PkgConfigPkg': CheckPkgConfigPkg,
	'BoostDateTimeCanNanosec': CheckBoostDateTimeCanNanosec,
	'TemplateRepo': CheckTemplateRepo
}

conf = Configure(env, custom_tests = tests)
AddSysOpts(conf.env)

conf.LinkerAsNeeded()
conf.LinkerExportDynamic()
#conf.TemplateRepo()
if conf.env['OPTIMIZATION'] != 'none':
	conf.Optimization()
conf.Warnings()
if conf.env['HIDE_SYMBOLS'] and conf.env['DEBUG'] == 0:
	conf.CompilerVisibility()
if conf.env['DEBUG']:
	conf.Debug()
if not conf.CheckCXXHeader('boost/config.hpp', '<>'):
	print 'Boost headers are not installed'
	Exit(1)

boost_thread_lib = 'boost_thread' + conf.env['BOOST_LIBSUFFIX']
if not conf.CheckLib(boost_thread_lib, language = 'c++'):
	print 'Boost threading library is not installed:', boost_thread_lib
	Exit(1)

boost_date_time_lib = 'boost_date_time' + conf.env['BOOST_LIBSUFFIX']
if not conf.CheckLib(boost_date_time_lib, language = 'c++'):
	print 'Boost date_time library is not installed:', boost_date_time_lib
	Exit(1)

#boost_popt_lib = 'boost_program_options' + conf.env['BOOST_LIBSUFFIX']
#if not conf.CheckLib(boost_popt_lib, language = 'c++'):
#	print 'Boost date_time library is not installed:', boost_date_time_lib
#	Exit(1)

boost_fs_lib = 'boost_filesystem' + conf.env['BOOST_LIBSUFFIX']
if not conf.CheckLib(boost_fs_lib, language = 'c++'):
	print 'Boost filesystem library is not installed:', boost_fs_lib
	Exit(1)

#conf.BoostDateTimeCanNanosec()

conf.CheckLib('rt')

if conf.CheckCHeader('unistd.h', '<>'):
	conf.env.Append(CPPDEFINES = 'HAS_UNISTD_H')

if not conf.PkgConfigPkg('sigc++-2.0'):
	print "sigc++-2.0 not found. If you have installed sigc++-2.0 check pkg-config setup."
	Exit(1)

conf.env.ParseConfig('pkg-config --cflags sigc++-2.0')
conf.env.ParseConfig('pkg-config --libs sigc++-2.0')

Return('conf')
