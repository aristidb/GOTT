<html xmlns:v="urn:schemas-microsoft-com:vml"
xmlns:o="urn:schemas-microsoft-com:office:office"
xmlns:w="urn:schemas-microsoft-com:office:word"
xmlns="http://www.w3.org/TR/REC-html40">

<head>
<meta http-equiv=Content-Type content="text/html; charset=windows-1252">
<meta name=ProgId content=Word.Document>
<meta name=Generator content="Microsoft Word 9">
<meta name=Originator content="Microsoft Word 9">
<link rel=File-List href="./rtl_files/filelist.xml">
<title>Contents</title>
<!--[if gte mso 9]><xml>
 <o:DocumentProperties>
  <o:Author>Your Magesty</o:Author>
  <o:Template>Normal</o:Template>
  <o:LastAuthor>Your Magesty</o:LastAuthor>
  <o:Revision>36</o:Revision>
  <o:TotalTime>3136</o:TotalTime>
  <o:Created>2004-02-01T16:42:00Z</o:Created>
  <o:LastSaved>2004-04-09T11:28:00Z</o:LastSaved>
  <o:Pages>21</o:Pages>
  <o:Words>8028</o:Words>
  <o:Characters>45763</o:Characters>
  <o:Company>Dell - Personal Systems Group</o:Company>
  <o:Lines>381</o:Lines>
  <o:Paragraphs>91</o:Paragraphs>
  <o:CharactersWithSpaces>56200</o:CharactersWithSpaces>
  <o:Version>9.3821</o:Version>
 </o:DocumentProperties>
</xml><![endif]--><!--[if gte mso 9]><xml>
 <w:WordDocument>
  <w:DoNotShowRevisions/>
  <w:DoNotPrintRevisions/>
 </w:WordDocument>
</xml><![endif]-->
<style>
<!--
 /* Font Definitions */
@font-face
	{font-family:Courier;
	panose-1:0 0 0 0 0 0 0 0 0 0;
	mso-font-alt:"Courier New";
	mso-font-charset:0;
	mso-generic-font-family:modern;
	mso-font-format:other;
	mso-font-pitch:fixed;
	mso-font-signature:3 0 0 0 1 0;}
@font-face
	{font-family:"MS Mincho";
	panose-1:0 0 0 0 0 0 0 0 0 0;
	mso-font-alt:"\FF2D\FF33 \660E\671D";
	mso-font-charset:128;
	mso-generic-font-family:roman;
	mso-font-format:other;
	mso-font-pitch:fixed;
	mso-font-signature:1 134676480 16 0 131072 0;}
@font-face
	{font-family:"\@MS Mincho";
	panose-1:0 0 0 0 0 0 0 0 0 0;
	mso-font-charset:128;
	mso-generic-font-family:roman;
	mso-font-format:other;
	mso-font-pitch:fixed;
	mso-font-signature:1 134676480 16 0 131072 0;}
 /* Style Definitions */
p.MsoNormal, li.MsoNormal, div.MsoNormal
	{mso-style-parent:"";
	margin-top:0in;
	margin-right:0in;
	margin-bottom:12.0pt;
	margin-left:0in;
	mso-pagination:widow-orphan;
	font-size:12.0pt;
	font-family:Arial;
	mso-fareast-font-family:"Times New Roman";
	mso-bidi-font-family:"Times New Roman";}
h1
	{mso-style-next:Normal;
	margin-top:12.0pt;
	margin-right:0in;
	margin-bottom:3.0pt;
	margin-left:0in;
	mso-pagination:widow-orphan;
	page-break-after:avoid;
	mso-outline-level:1;
	font-size:18.0pt;
	mso-bidi-font-size:16.0pt;
	font-family:Arial;
	mso-font-kerning:16.0pt;
	font-weight:bold;}
h2
	{mso-style-next:Normal;
	margin-top:12.0pt;
	margin-right:0in;
	margin-bottom:3.0pt;
	margin-left:0in;
	mso-pagination:widow-orphan;
	page-break-after:avoid;
	mso-outline-level:2;
	font-size:16.0pt;
	mso-bidi-font-size:14.0pt;
	font-family:Arial;
	font-weight:bold;
	font-style:italic;}
h3
	{mso-style-next:Normal;
	margin-top:12.0pt;
	margin-right:0in;
	margin-bottom:3.0pt;
	margin-left:0in;
	mso-pagination:widow-orphan;
	page-break-after:avoid;
	mso-outline-level:3;
	font-size:14.0pt;
	mso-bidi-font-size:13.0pt;
	font-family:Arial;
	font-weight:bold;}
p.MsoToc1, li.MsoToc1, div.MsoToc1
	{mso-style-update:auto;
	mso-style-next:Normal;
	margin-top:12.0pt;
	margin-right:0in;
	margin-bottom:6.0pt;
	margin-left:0in;
	mso-pagination:widow-orphan;
	font-size:12.0pt;
	font-family:"Times New Roman";
	mso-fareast-font-family:"Times New Roman";
	font-weight:bold;}
p.MsoToc2, li.MsoToc2, div.MsoToc2
	{mso-style-update:auto;
	mso-style-next:Normal;
	margin-top:6.0pt;
	margin-right:0in;
	margin-bottom:0in;
	margin-left:12.0pt;
	margin-bottom:.0001pt;
	mso-pagination:widow-orphan;
	font-size:12.0pt;
	font-family:"Times New Roman";
	mso-fareast-font-family:"Times New Roman";
	font-style:italic;}
p.MsoToc3, li.MsoToc3, div.MsoToc3
	{mso-style-update:auto;
	mso-style-next:Normal;
	margin-top:0in;
	margin-right:0in;
	margin-bottom:0in;
	margin-left:24.0pt;
	margin-bottom:.0001pt;
	mso-pagination:widow-orphan;
	font-size:12.0pt;
	font-family:"Times New Roman";
	mso-fareast-font-family:"Times New Roman";}
p.MsoToc4, li.MsoToc4, div.MsoToc4
	{mso-style-update:auto;
	mso-style-next:Normal;
	margin-top:0in;
	margin-right:0in;
	margin-bottom:0in;
	margin-left:.5in;
	margin-bottom:.0001pt;
	mso-pagination:widow-orphan;
	font-size:12.0pt;
	font-family:"Times New Roman";
	mso-fareast-font-family:"Times New Roman";}
p.MsoToc5, li.MsoToc5, div.MsoToc5
	{mso-style-update:auto;
	mso-style-next:Normal;
	margin-top:0in;
	margin-right:0in;
	margin-bottom:0in;
	margin-left:48.0pt;
	margin-bottom:.0001pt;
	mso-pagination:widow-orphan;
	font-size:12.0pt;
	font-family:"Times New Roman";
	mso-fareast-font-family:"Times New Roman";}
p.MsoToc6, li.MsoToc6, div.MsoToc6
	{mso-style-update:auto;
	mso-style-next:Normal;
	margin-top:0in;
	margin-right:0in;
	margin-bottom:0in;
	margin-left:60.0pt;
	margin-bottom:.0001pt;
	mso-pagination:widow-orphan;
	font-size:12.0pt;
	font-family:"Times New Roman";
	mso-fareast-font-family:"Times New Roman";}
p.MsoToc7, li.MsoToc7, div.MsoToc7
	{mso-style-update:auto;
	mso-style-next:Normal;
	margin-top:0in;
	margin-right:0in;
	margin-bottom:0in;
	margin-left:1.0in;
	margin-bottom:.0001pt;
	mso-pagination:widow-orphan;
	font-size:12.0pt;
	font-family:"Times New Roman";
	mso-fareast-font-family:"Times New Roman";}
p.MsoToc8, li.MsoToc8, div.MsoToc8
	{mso-style-update:auto;
	mso-style-next:Normal;
	margin-top:0in;
	margin-right:0in;
	margin-bottom:0in;
	margin-left:84.0pt;
	margin-bottom:.0001pt;
	mso-pagination:widow-orphan;
	font-size:12.0pt;
	font-family:"Times New Roman";
	mso-fareast-font-family:"Times New Roman";}
p.MsoToc9, li.MsoToc9, div.MsoToc9
	{mso-style-update:auto;
	mso-style-next:Normal;
	margin-top:0in;
	margin-right:0in;
	margin-bottom:0in;
	margin-left:96.0pt;
	margin-bottom:.0001pt;
	mso-pagination:widow-orphan;
	font-size:12.0pt;
	font-family:"Times New Roman";
	mso-fareast-font-family:"Times New Roman";}
p.MsoToaHeading, li.MsoToaHeading, div.MsoToaHeading
	{mso-style-next:Normal;
	margin-top:6.0pt;
	margin-right:0in;
	margin-bottom:12.0pt;
	margin-left:0in;
	mso-pagination:widow-orphan;
	font-size:12.0pt;
	font-family:Arial;
	mso-fareast-font-family:"Times New Roman";
	font-weight:bold;}
p.MsoList2, li.MsoList2, div.MsoList2
	{margin-top:0in;
	margin-right:0in;
	margin-bottom:12.0pt;
	margin-left:.5in;
	text-indent:-.25in;
	mso-pagination:widow-orphan;
	font-size:12.0pt;
	font-family:Arial;
	mso-fareast-font-family:"Times New Roman";
	mso-bidi-font-family:"Times New Roman";}
p.MsoListBullet2, li.MsoListBullet2, div.MsoListBullet2
	{mso-style-update:auto;
	margin-top:0in;
	margin-right:0in;
	margin-bottom:12.0pt;
	margin-left:.5in;
	text-indent:-.25in;
	mso-pagination:widow-orphan;
	mso-list:l0 level1 lfo3;
	tab-stops:list .5in;
	font-size:12.0pt;
	font-family:Arial;
	mso-fareast-font-family:"Times New Roman";
	mso-bidi-font-family:"Times New Roman";}
p.MsoBodyText, li.MsoBodyText, div.MsoBodyText
	{margin-top:0in;
	margin-right:0in;
	margin-bottom:6.0pt;
	margin-left:0in;
	mso-pagination:widow-orphan;
	font-size:12.0pt;
	font-family:Arial;
	mso-fareast-font-family:"Times New Roman";
	mso-bidi-font-family:"Times New Roman";}
p.MsoBodyText2, li.MsoBodyText2, div.MsoBodyText2
	{margin-top:0in;
	margin-right:0in;
	margin-bottom:12.0pt;
	margin-left:0in;
	mso-pagination:widow-orphan;
	font-size:12.0pt;
	font-family:Arial;
	mso-fareast-font-family:"Times New Roman";
	mso-bidi-font-family:"Times New Roman";
	color:black;}
a:link, span.MsoHyperlink
	{color:blue;
	text-decoration:underline;
	text-underline:single;}
a:visited, span.MsoHyperlinkFollowed
	{color:purple;
	text-decoration:underline;
	text-underline:single;}
p.MsoPlainText, li.MsoPlainText, div.MsoPlainText
	{margin:0in;
	margin-bottom:.0001pt;
	mso-pagination:widow-orphan;
	font-size:10.0pt;
	font-family:"Courier New";
	mso-fareast-font-family:"Times New Roman";}
p
	{margin-right:0in;
	mso-margin-top-alt:auto;
	mso-margin-bottom-alt:auto;
	margin-left:0in;
	mso-pagination:widow-orphan;
	font-size:12.0pt;
	font-family:"Times New Roman";
	mso-fareast-font-family:"Times New Roman";}
p.Code, li.Code, div.Code
	{mso-style-name:Code;
	margin:0in;
	margin-bottom:.0001pt;
	mso-pagination:widow-orphan;
	background:#E6E6E6;
	font-size:10.0pt;
	mso-bidi-font-size:12.0pt;
	font-family:"Courier New";
	mso-fareast-font-family:"Times New Roman";
	mso-bidi-font-family:"Times New Roman";}
span.Inlinecode
	{mso-style-name:"Inline code";
	mso-ascii-font-family:"Courier New";
	mso-hansi-font-family:"Courier New";}
ins
	{mso-style-type:export-only;
	text-decoration:none;}
span.msoDel
	{mso-style-type:export-only;
	mso-style-name:"";
	text-decoration:line-through;
	display:none;
	color:red;}
@page Section1
	{size:8.5in 11.0in;
	margin:1.0in 1.25in 1.0in 1.25in;
	mso-header-margin:.5in;
	mso-footer-margin:.5in;
	mso-paper-source:0;}
div.Section1
	{page:Section1;}
 /* List Definitions */
@list l0
	{mso-list-id:-125;
	mso-list-type:simple;
	mso-list-template-ids:1871641012;}
@list l0:level1
	{mso-level-number-format:bullet;
	mso-level-style-link:"List Bullet 2";
	mso-level-text:\F0B7;
	mso-level-tab-stop:.5in;
	mso-level-number-position:left;
	text-indent:-.25in;
	font-family:Symbol;}
@list l1
	{mso-list-id:132984286;
	mso-list-type:hybrid;
	mso-list-template-ids:-925087508 67698703 67698713 67698715 67698703 67698713 67698715 67698703 67698713 67698715;}
@list l2
	{mso-list-id:1306080554;
	mso-list-type:hybrid;
	mso-list-template-ids:-1261811792 67698703 67698713 67698715 67698703 67698713 67698715 67698703 67698713 67698715;}
@list l3
	{mso-list-id:2034768087;
	mso-list-type:hybrid;
	mso-list-template-ids:1419299924 67698703 67698713 67698715 67698703 67698713 67698715 67698703 67698713 67698715;}
@list l3:level1
	{mso-level-tab-stop:39.0pt;
	mso-level-number-position:left;
	margin-left:39.0pt;
	text-indent:-.25in;}
ol
	{margin-bottom:0in;}
ul
	{margin-bottom:0in;}
-->
</style>
<!--[if gte mso 9]><xml>
 <o:shapedefaults v:ext="edit" spidmax="1027"/>
</xml><![endif]--><!--[if gte mso 9]><xml>
 <o:shapelayout v:ext="edit">
  <o:idmap v:ext="edit" data="1"/>
 </o:shapelayout></xml><![endif]-->
</head>

<body lang=EN-US link=blue vlink=purple style='tab-interval:.5in'>

<div class=Section1>

<p class=MsoToc1 style='tab-stops:right dotted 431.5pt'><!--[if supportFields]><span
style='mso-element:field-begin'></span><span style="mso-spacerun:
yes"> </span>TOC \o &quot;1-3&quot; \n \h \z <span style='mso-element:field-separator'></span><![endif]--><span
class=MsoHyperlink><a href="#_Toc68859937"><span style='mso-bidi-font-size:
18.0pt'>Motivation</span></a></span><span style='font-weight:normal'><o:p></o:p></span></p>

<p class=MsoToc1 style='tab-stops:right dotted 431.5pt'><span
class=MsoHyperlink><a href="#_Toc68859938"><span style='mso-bidi-font-size:
18.0pt'>Example</span></a></span><span style='font-weight:normal'><o:p></o:p></span></p>

<p class=MsoToc1 style='tab-stops:right dotted 431.5pt'><span
class=MsoHyperlink><a href="#_Toc68859939"><span style='mso-bidi-font-size:
18.0pt'>Main Concepts</span></a></span><span style='font-weight:normal'><o:p></o:p></span></p>

<p class=MsoToc2 style='tab-stops:right dotted 431.5pt'><span
class=MsoHyperlink><a href="#_Toc68859940"><span style='mso-bidi-font-size:
16.0pt'>Columns</span></a></span><span style='font-style:normal'><o:p></o:p></span></p>

<p class=MsoToc2 style='tab-stops:right dotted 431.5pt'><span
class=MsoHyperlink><a href="#_Toc68859941"><span style='mso-bidi-font-size:
16.0pt'>Column Lists</span></a></span><span style='font-style:normal'><o:p></o:p></span></p>

<p class=MsoToc2 style='tab-stops:right dotted 431.5pt'><span
class=MsoHyperlink><a href="#_Toc68859942"><span style='mso-bidi-font-size:
16.0pt'>Tuples</span></a></span><span style='font-style:normal'><o:p></o:p></span></p>

<p class=MsoToc2 style='tab-stops:right dotted 431.5pt'><span
class=MsoHyperlink><a href="#_Toc68859943"><span style='mso-bidi-font-size:
16.0pt'>Tables</span></a></span><span style='font-style:normal'><o:p></o:p></span></p>

<p class=MsoToc2 style='tab-stops:right dotted 431.5pt'><span
class=MsoHyperlink><a href="#_Toc68859944"><span style='mso-bidi-font-size:
16.0pt'>Table implementations</span></a></span><span style='font-style:normal'><o:p></o:p></span></p>

<p class=MsoToc2 style='tab-stops:right dotted 431.5pt'><span
class=MsoHyperlink><a href="#_Toc68859945"><span style='mso-bidi-font-size:
16.0pt'>Iterators</span></a></span><span style='font-style:normal'><o:p></o:p></span></p>

<p class=MsoToc2 style='tab-stops:right dotted 431.5pt'><span
class=MsoHyperlink><a href="#_Toc68859946"><span style='mso-bidi-font-size:
16.0pt'>Relations</span></a></span><span style='font-style:normal'><o:p></o:p></span></p>

<p class=MsoToc3 style='tab-stops:right dotted 431.5pt'><span
class=MsoHyperlink><a href="#_Toc68859947"><span style='mso-bidi-font-size:
14.0pt'>selection</span></a></span></p>

<p class=MsoToc3 style='tab-stops:right dotted 431.5pt'><span
class=MsoHyperlink><a href="#_Toc68859948"><span style='mso-bidi-font-size:
14.0pt'>projection</span></a></span></p>

<p class=MsoToc3 style='tab-stops:right dotted 431.5pt'><span
class=MsoHyperlink><a href="#_Toc68859949"><span style='mso-bidi-font-size:
14.0pt'>cross_product</span></a></span></p>

<p class=MsoToc3 style='tab-stops:right dotted 431.5pt'><span
class=MsoHyperlink><a href="#_Toc68859950"><span style='mso-bidi-font-size:
14.0pt'>extension</span></a></span></p>

<p class=MsoToc3 style='tab-stops:right dotted 431.5pt'><span
class=MsoHyperlink><a href="#_Toc68859951"><span style='mso-bidi-font-size:
14.0pt'>Set operations</span></a></span></p>

<p class=MsoToc3 style='tab-stops:right dotted 431.5pt'><span
class=MsoHyperlink><a href="#_Toc68859952"><span style='mso-bidi-font-size:
14.0pt'>difference</span></a></span></p>

<p class=MsoToc3 style='tab-stops:right dotted 431.5pt'><span
class=MsoHyperlink><a href="#_Toc68859953"><span style='mso-bidi-font-size:
14.0pt'>diff</span></a></span></p>

<p class=MsoToc3 style='tab-stops:right dotted 431.5pt'><span
class=MsoHyperlink><a href="#_Toc68859954"><span style='mso-bidi-font-size:
14.0pt'>Union</span></a></span></p>

<p class=MsoToc3 style='tab-stops:right dotted 431.5pt'><span
class=MsoHyperlink><a href="#_Toc68859955"><span style='mso-bidi-font-size:
14.0pt'>intersection</span></a></span></p>

<p class=MsoToc3 style='tab-stops:right dotted 431.5pt'><span
class=MsoHyperlink><a href="#_Toc68859956"><span style='mso-bidi-font-size:
14.0pt'>isection</span></a></span></p>

<p class=MsoToc3 style='tab-stops:right dotted 431.5pt'><span
class=MsoHyperlink><a href="#_Toc68859957"><span style='mso-bidi-font-size:
14.0pt'>rsection</span></a></span></p>

<p class=MsoToc3 style='tab-stops:right dotted 431.5pt'><span
class=MsoHyperlink><a href="#_Toc68859958"><span style='mso-bidi-font-size:
14.0pt'>range</span></a></span></p>

<p class=MsoToc3 style='tab-stops:right dotted 431.5pt'><span
class=MsoHyperlink><a href="#_Toc68859959"><span style='mso-bidi-font-size:
14.0pt'>range_selection</span></a></span></p>

<p class=MsoToc3 style='tab-stops:right dotted 431.5pt'><span
class=MsoHyperlink><a href="#_Toc68859960"><span style='mso-bidi-font-size:
14.0pt'>equal_selection</span></a></span></p>

<p class=MsoToc3 style='tab-stops:right dotted 431.5pt'><span
class=MsoHyperlink><a href="#_Toc68859961"><span style='mso-bidi-font-size:
14.0pt'>range_join</span></a></span></p>

<p class=MsoToc3 style='tab-stops:right dotted 431.5pt'><span
class=MsoHyperlink><a href="#_Toc68859962"><span style='mso-bidi-font-size:
14.0pt'>join_xx</span></a></span></p>

<p class=MsoToc3 style='tab-stops:right dotted 431.5pt'><span
class=MsoHyperlink><a href="#_Toc68859963"><span style='mso-bidi-font-size:
14.0pt'>merge</span></a></span></p>

<p class=MsoToc3 style='tab-stops:right dotted 431.5pt'><span
class=MsoHyperlink><a href="#_Toc68859964"><span style='mso-bidi-font-size:
14.0pt'>rename</span></a></span></p>

<p class=MsoToc3 style='tab-stops:right dotted 431.5pt'><span
class=MsoHyperlink><a href="#_Toc68859965"><span style='mso-bidi-font-size:
14.0pt'>groupby</span></a></span></p>

<p class=MsoToc1 style='tab-stops:right dotted 431.5pt'><span
class=MsoHyperlink><a href="#_Toc68859966"><span style='mso-bidi-font-size:
18.0pt'>Indexes</span></a></span><span style='font-weight:normal'><o:p></o:p></span></p>

<p class=MsoToc1 style='tab-stops:right dotted 431.5pt'><span
class=MsoHyperlink><a href="#_Toc68859967"><span style='mso-bidi-font-size:
18.0pt'>Invert</span></a></span><span style='font-weight:normal'><o:p></o:p></span></p>

<p class=MsoToc1 style='tab-stops:right dotted 431.5pt'><span
class=MsoHyperlink><a href="#_Toc68859968"><span style='mso-bidi-font-size:
18.0pt'>Let the compiler figure it out</span></a></span><span style='font-weight:
normal'><o:p></o:p></span></p>

<p class=MsoToc1 style='tab-stops:right dotted 431.5pt'><span
class=MsoHyperlink><a href="#_Toc68859969"><span style='mso-bidi-font-size:
18.0pt'>Transactions</span></a></span><span style='font-weight:normal'><o:p></o:p></span></p>

<p class=MsoToc2 style='tab-stops:right dotted 431.5pt'><span
class=MsoHyperlink><a href="#_Toc68859970"><span style='mso-bidi-font-size:
16.0pt'>Deltas for tables</span></a></span><span style='font-style:normal'><o:p></o:p></span></p>

<p class=MsoToc2 style='tab-stops:right dotted 431.5pt'><span
class=MsoHyperlink><a href="#_Toc68859971"><span style='mso-bidi-font-size:
16.0pt'>Incremental index update</span></a></span><span style='font-style:normal'><o:p></o:p></span></p>

<p class=MsoToc2 style='tab-stops:right dotted 431.5pt'><span
class=MsoHyperlink><a href="#_Toc68859972"><span style='mso-bidi-font-size:
16.0pt'>Full reset/rebuild</span></a></span><span style='font-style:normal'><o:p></o:p></span></p>

<p class=MsoToc2 style='tab-stops:right dotted 431.5pt'><span
class=MsoHyperlink><a href="#_Toc68859973"><span style='mso-bidi-font-size:
16.0pt'>Example</span></a></span><span style='font-style:normal'><o:p></o:p></span></p>

<p class=MsoToc2 style='tab-stops:right dotted 431.5pt'><span
class=MsoHyperlink><a href="#_Toc68859974"><span style='mso-bidi-font-size:
16.0pt'>Reference</span></a></span><span style='font-style:normal'><o:p></o:p></span></p>

<p class=MsoToc3 style='tab-stops:right dotted 431.5pt'><span
class=MsoHyperlink><a href="#_Toc68859975"><span style='mso-bidi-font-size:
14.0pt'>transaction</span></a></span></p>

<p class=MsoToc3 style='tab-stops:right dotted 431.5pt'><span
class=MsoHyperlink><a href="#_Toc68859976"><span style='mso-bidi-font-size:
14.0pt'>expression_registry</span></a></span></p>

<p class=MsoToc3 style='tab-stops:right dotted 431.5pt'><span
class=MsoHyperlink><a href="#_Toc68859977"><span style='mso-bidi-font-size:
14.0pt'>delta</span></a></span></p>

<p class=MsoToc3 style='tab-stops:right dotted 431.5pt'><span
class=MsoHyperlink><a href="#_Toc68859978"><span style='mso-bidi-font-size:
14.0pt'>modified</span></a></span></p>

<p class=MsoToc1 style='tab-stops:right dotted 431.5pt'><span
class=MsoHyperlink><a href="#_Toc68859979"><span style='mso-bidi-font-size:
18.0pt'>Tests</span></a></span><span style='font-weight:normal'><o:p></o:p></span></p>

<p class=MsoToc1 style='tab-stops:right dotted 431.5pt'><span
class=MsoHyperlink><a href="#_Toc68859980"><span style='mso-bidi-font-size:
18.0pt'>Compilers</span></a></span><span style='font-weight:normal'><o:p></o:p></span></p>

<p class=MsoToc1 style='tab-stops:right dotted 431.5pt'><span
class=MsoHyperlink><a href="#_Toc68859981"><span style='mso-bidi-font-size:
18.0pt'>Bibliography</span></a></span><span style='font-weight:normal'><o:p></o:p></span></p>

<h1 style='margin:0in;margin-bottom:.0001pt'><!--[if supportFields]><span
style='font-size:12.0pt;font-family:"Times New Roman";mso-font-kerning:0pt'><span
style='mso-element:field-end'></span></span><![endif]--><a name="_Toc68859937">Motivation</a></h1>

<p class=MsoNormal>While designing a C++ application with UML it is quite
common to end with diagrams, which contain not only hierarchies and
aggregations, but also multi-way associations between classes. The relational
tables and relational operators are a natural way to express them.</p>

<p class=MsoNormal>The mainstream approach to get them requires defining tables
inside a relational database, and then accessing data through SQL/ODBC. For
many applications, especially those, which don't deal with very big persistent
tables, adding a DBMS is a tough decision, which affects cost, memory
footprint, way of system deploying and other aspects. It also has important
drawbacks that are obvious to every C++ programmer:</p>

<p class=MsoNormal>The layout of tables is defined outside the program.
Therefore the compiler is not able to ensure consistency of data structures and
the program code. If the programmer fails to manually ensure this consistency,
it may result in run-time errors. Same story is with SQL, which is an alien to
C++. Passing SQL code in a string not only doesn’t allow ensure the type
safety, but also excludes any compile-time checks whatsoever. </p>

<p class=MsoNormal>From other side, for many common cases flexibility of SQL is
overkill. While operating huge databases query translation and optimization
time is not an issue, but, when the size of tables is relatively small, SQL
translation may cause significant overhead.</p>

<p class=MsoNormal>Traditional DBMS usually limit data types to numbers,
strings and dates. For a typical C++ program, which operates on many
user-defined classes, this is unnecessary strong limitation. The application
needs some object-to-relation mapping layer, which adds to complexity of the
system.</p>

<p class=MsoNormal>Situations, where relational operations and computations are
interleaved, are particularly hard to code efficiently, because computations
are either performed by DBMS, usually via slow interpretation, or by caller
program, which leads to extremely high number of DBMS requests.</p>

<p class=MsoNormal>RTL is an attempt to create a facility that would be free
from the above drawbacks, and make relational tables and relational operations
convenient to use from a C++ program.</p>

<p class=MsoNormal style='mso-margin-top-alt:auto;mso-margin-bottom-alt:auto'>It
is based on extensive use of C++ templates and template metaprogramming
techniques.</p>

<h1><a name="_Toc68859938">Example</a></h1>

<p class=MsoNormal style='mso-margin-top-alt:auto;mso-margin-bottom-alt:auto'>Suppose
we have a list of cities with their names and coordinates. The problem will be to
find every (unordered) pair of cities with distance between them less than a
given number (for simplicity 3000 km).</p>

<p class=Code>/* 01 */<span style='mso-tab-count:1'>    </span>#include
&lt;math.h&gt;</p>

<p class=Code>/* 02 */<span style='mso-tab-count:1'>    </span>#include
&quot;rtl.hpp&quot;</p>

<p class=Code>/* 03 */<span style="mso-spacerun: yes">    </span>#include
&quot;utils.hpp&quot;</p>

<p class=Code>/* 04 */<span style='mso-tab-count:1'>    </span>using namespace
rel;</p>

<p class=Code>/* 05 */</p>

<p class=Code>/* 06 */<span style='mso-tab-count:1'>    </span>static const
double pi = 3.1415927;</p>

<p class=Code>/* 07 */<span style='mso-tab-count:1'>    </span>static const
double radius = 6371.0; // in km.</p>

<p class=Code>/* 08 */</p>

<p class=Code>/* 09 */<span style='mso-tab-count:1'>    </span>class EarthCoord
</p>

<p class=Code>/* 10 */<span style='mso-tab-count:1'>    </span>{</p>

<p class=Code>/* 11 */<span style='mso-tab-count:1'>    </span>public:</p>

<p class=Code>/* 12 */<span style='mso-tab-count:2'>          </span>EarthCoord(double
lat, double lng) : lat_((lat/180.)*pi), lng_((lng/180.)*pi) {}</p>

<p class=Code>/* 13 */<span style='mso-tab-count:2'>          </span>EarthCoord()
: lat_(0.), lng_(0.) {}</p>

<p class=Code>/* 14 */<span style='mso-tab-count:2'>          </span>double
distance(const EarthCoord&amp; other) const</p>

<p class=Code>/* 15 */<span style='mso-tab-count:2'>          </span>{</p>

<p class=Code>/* 16 */<span style='mso-tab-count:3'>                </span>double
s =<span style='mso-tab-count:1'>  </span>cos(lng_)*cos(lat_)*cos(other.lng_)*cos(other.lat_)+</p>

<p class=Code>/* 17 */`<span style='mso-tab-count:5'>                           </span>sin(lng_)*cos(lat_)*sin(other.lng_)*cos(other.lat_)+</p>

<p class=Code>/* 18 */<span style='mso-tab-count:5'>                            </span>sin(lat_)*sin(other.lat_);</p>

<p class=Code>/* 19 */<span style='mso-tab-count:3'>                </span>return
radius*acos(s);</p>

<p class=Code>/* 20 */<span style='mso-tab-count:2'>          </span>}</p>

<p class=Code>/* 21 */<span style='mso-tab-count:2'>          </span>double
getLatitude() const {return lat_;}</p>

<p class=Code>/* 22 */<span style='mso-tab-count:2'>          </span>double
getLongitude() const {return lng_;}</p>

<p class=Code>/* 23 */<span style='mso-tab-count:1'>    </span>private:</p>

<p class=Code>/* 24 */<span style='mso-tab-count:2'>          </span>double
lat_;</p>

<p class=Code>/* 25 */<span style='mso-tab-count:2'>          </span>double
lng_;</p>

<p class=Code>/* 26 */<span style='mso-tab-count:1'>    </span>};</p>

<p class=Code>/* 27 */</p>

<p class=Code>/* 28 */<span style='mso-tab-count:1'>    </span>std::ostream&amp;
operator &lt;&lt;(std::ostream&amp; s, const EarthCoord&amp; c)</p>

<p class=Code>/* 29 */<span style='mso-tab-count:1'>    </span>{</p>

<p class=Code>/* 30 */<span style='mso-tab-count:2'>          </span>return s
&lt;&lt; c.getLatitude() &lt;&lt; &quot; &quot; &lt;&lt; c.getLongitude();</p>

<p class=Code>/* 31 */<span style='mso-tab-count:1'>    </span>}</p>

<p class=Code>/* 32 */</p>

<p class=Code>/* 33 */<span style='mso-tab-count:1'>    </span>BOOST_RTL_DEFINE_COLUMN(std::string,
name);</p>

<p class=Code>/* 34 */<span style='mso-tab-count:1'>    </span>BOOST_RTL_DEFINE_COLUMN(EarthCoord,
coord);</p>

<p class=Code>/* 35 */</p>

<p class=Code>/* 36 */<span style='mso-tab-count:1'>    </span>typedef
boost::mpl::vector2&lt;name,coord&gt; fld_list;</p>

<p class=Code>/* 37 */<span style='mso-tab-count:1'>    </span>typedef
boost::mpl::vector1&lt;name&gt; srt_list;</p>

<p class=Code>/* 38 */<span style='mso-tab-count:1'>    </span>struct
cities_info : table_info</p>

<p class=Code>/* 39 */<span style='mso-tab-count:1'>    </span>&lt;</p>

<p class=Code>/* 40 */<span style='mso-tab-count:2'>          </span>fld_list,</p>

<p class=Code>/* 41 */<span style='mso-tab-count:2'>          </span>srt_list</p>

<p class=Code>/* 42 */<span style='mso-tab-count:1'>    </span>&gt; {};</p>

<p class=Code>/* 43 */<span style='mso-tab-count:1'>    </span>typedef
table&lt;cities_info&gt; cities_type;<span style='mso-tab-count:1'>   </span></p>

<p class=Code>/* 44 */<span style='mso-tab-count:1'>    </span>typedef
cities_type::value_type tup;</p>

<p class=Code>/* 45 */</p>

<p class=Code>/* 46 */<span style='mso-tab-count:1'>    </span>struct
distance_less_than</p>

<p class=Code>/* 47 */<span style='mso-tab-count:1'>    </span>{</p>

<p class=Code>/* 48 */<span style='mso-tab-count:2'>          </span>distance_less_than(double
d) : d_(d) {}</p>

<p class=Code>/* 49 */<span style='mso-tab-count:2'>          </span>template
&lt;class Tuple&gt; bool operator()(const Tuple&amp; tp) const</p>

<p class=Code>/* 50 */<span style='mso-tab-count:2'>          </span>{</p>

<p class=Code>/* 51 */<span style='mso-tab-count:3'>                </span>return
BOOST_RTL_FIELD(tp,coord).distance(BOOST_RTL_FIELD(tp,coord1)) &lt; d_;</p>

<p class=Code>/* 52 */<span style='mso-tab-count:2'>          </span>}<span
style='mso-tab-count:2'>           </span></p>

<p class=Code>/* 53 */<span style='mso-tab-count:2'>          </span>double d_;</p>

<p class=Code>/* 54 */<span style='mso-tab-count:1'>    </span>};</p>

<p class=Code>/* 55 */<span style='mso-tab-count:1'>    </span></p>

<p class=Code>/* 56 */<span style='mso-tab-count:1'>    </span>struct a;</p>

<p class=Code>/* 57 */</p>

<p class=Code>/* 58 */ <span style='mso-tab-count:1'>   </span>typedef
rel::alias&lt;coord,a&gt; coord1;</p>

<p class=Code>/* 59 */<span style='mso-tab-count:1'>    </span>typedef
rel::alias&lt;name,a&gt; name1;</p>

<p class=Code>/* 60 */</p>

<p class=Code>/* 61 */<span style='mso-tab-count:1'>    </span>int main ()</p>

<p class=Code>/* 62 */<span style='mso-tab-count:1'>    </span>{</p>

<p class=Code>/* 63 */<span style='mso-tab-count:2'>          </span>cities_type
cities;</p>

<p class=Code>/* 64 */<span style='mso-tab-count:2'>          </span>cities.insert(tup(&quot;Miami<span
style="mso-spacerun: yes">        </span>&quot;,EarthCoord(25.7739,-80.194)));</p>

<p class=Code>/* 65 */<span style='mso-tab-count:2'>          </span>cities.insert(tup(&quot;Washington
DC&quot;,EarthCoord(38.895,-77.0367)));</p>

<p class=Code>/* 66 */<span style='mso-tab-count:2'>          </span>cities.insert(tup(&quot;Denver<span
style="mso-spacerun: yes">       </span>&quot;,EarthCoord(39.7392,-104.984)));</p>

<p class=Code>/* 67 */<span style='mso-tab-count:2'>          </span>cities.insert(tup(&quot;San
Francisco&quot;,EarthCoord(37.775,-122.418)));</p>

<p class=Code>/* 68 */<span style='mso-tab-count:2'>          </span>cities.insert(tup(&quot;New
York<span style="mso-spacerun: yes">    
</span>&quot;,EarthCoord(40.7142,-74.006)));</p>

<p class=Code>/* 69 */<span style='mso-tab-count:2'>          </span>cities.insert(tup(&quot;Boston<span
style="mso-spacerun: yes">       </span>&quot;,EarthCoord(42.3583,-71.060)));</p>

<p class=Code>/* 70 */<span style='mso-tab-count:2'>          </span>print(</p>

<p class=Code>/* 71 */<span style='mso-tab-count:3'>                </span>projection&lt;boost::mpl::vector2&lt;name,name1&gt;
&gt;</p>

<p class=Code>/* 72 */<span style='mso-tab-count:3'>                </span>(</p>

<p class=Code>/* 73 */<span style='mso-tab-count:4'>                      </span>selection</p>

<p class=Code>/* 74 */<span style='mso-tab-count:4'>                      </span>(</p>

<p class=Code>/* 75 */<span style='mso-tab-count:5'>                            </span>join_gt&lt;srt_list&gt;(cities,auto_rename&lt;a&gt;(cities)),</p>

<p class=Code>/* 76 */<span style='mso-tab-count:2'>          </span><span
style='mso-tab-count:3'>                  </span>distance_less_than(3000.)</p>

<p class=Code>/* 77 */<span style='mso-tab-count:4'>                      </span>)</p>

<p class=Code>/* 78 */<span style='mso-tab-count:3'>                </span>)</p>

<p class=Code>/* 79 */<span style='mso-tab-count:2'>          </span>);</p>

<p class=Code>/* 80 */<span style='mso-tab-count:2'>          </span>return 0;</p>

<p class=Code>/* 81 */<span style='mso-tab-count:1'>    </span>}</p>

<p class=MsoNormal style='mso-margin-top-alt:auto;mso-margin-bottom-alt:auto'>In
lines 2 and 3 we include all headers we need, line 4 says, that we are using
namespace rel, where RTL reside.</p>

<p class=MsoNormal style='mso-margin-top-alt:auto;mso-margin-bottom-alt:auto'>Lines
9 to 26 define type of spherical coordinates. Remember, there is no such type
in traditional RDBMS. Lines 28 to 31 define a way to visualize coordinates.
This code was used during debugging and is not actually necessary.</p>

<p class=MsoNormal style='mso-margin-top-alt:auto;mso-margin-bottom-alt:auto'>Lines
33 and 34 define columns. This is done by a macro, which takes column name and
type of the value as parameters. The macro creates a class for each column.</p>

<p class=MsoNormal style='mso-margin-top-alt:auto;mso-margin-bottom-alt:auto'>Line
36 defines list of columns of our base table. It says, that the table consists
of two columns: name of the city and its coordinates. </p>

<p class=MsoNormal style='mso-margin-top-alt:auto;mso-margin-bottom-alt:auto'>Line
37 defines sort order. Table is sorted by name of city. See, we do not have a
way to compare coordinates.</p>

<p class=MsoNormal style='mso-margin-top-alt:auto;mso-margin-bottom-alt:auto'>Lines
38 to 43 define table class. It is 3 stage activity: first we need make an
instance of table_info template class, which will contain all parameters of our
table, next we create structure cities_info, which inherits from table_info,
and then create instance of table class template.</p>

<p class=MsoNormal style='mso-margin-top-alt:auto;mso-margin-bottom-alt:auto'>In
line 44 we extract from table type of its tuple (row). We’ll need it, while
filling the table up.</p>

<p class=MsoNormal style='mso-margin-top-alt:auto;mso-margin-bottom-alt:auto'>Lines
46 to 54 define predicate functor distance_less_than. The functor is
parameterized with maximum allowed distance between cities.</p>

<p class=MsoNormal style='mso-margin-top-alt:auto;mso-margin-bottom-alt:auto'>Lines
56 to 59 are define new names of columns for cities_table. We need to rename
columns to be able join the table with itself, to keep names in the joined
table distinct.</p>

<p class=MsoNormal style='mso-margin-top-alt:auto;mso-margin-bottom-alt:auto'>Main
procedure resides between lines 61 and 81.<span style="mso-spacerun: yes"> 
</span>Line 63 declares variable of table type. In lines 64 to 69 we fill the
table, providing values of all fields in tuples. Line 70 to 79 represent actual
code of the relational query. Let us start from innermost operations:</p>

<p class=MsoNormal style='mso-margin-top-alt:auto;mso-margin-bottom-alt:auto'>At
line 75 we see, how to join table with itself. This operation takes our table
cities, rename it and joins with original cities table by name column. The join
condition is “greater than”, which let us see each pair of cities only once,
say instead of two tuples :</p>

<p class=MsoNormal style='mso-margin-top-alt:auto;mso-margin-bottom-alt:auto'>(“New
York “,&lt;NY coord&gt;,”Boston”,&lt;Boston coord&gt;) and (”Boston”,&lt;Boston
coord&gt;,“New York “,&lt;NY coord&gt;)</p>

<p class=MsoNormal style='mso-margin-top-alt:auto;mso-margin-bottom-alt:auto'>there
will be only one. Trivial pairs like (“New York “,&lt;NY coord&gt;,“New York
“,&lt;NY coord&gt;) will be excluded also.</p>

<p class=MsoNormal style='mso-margin-top-alt:auto;mso-margin-bottom-alt:auto'>Lines
73 to 77 are about selection from the join relation pairs of cities, which are
placed close than 3000 km. We instantiate predicate distance_less_than, which
servers as 2<sup>nd</sup> parameter to selection function.</p>

<p class=MsoNormal style='mso-margin-top-alt:auto;mso-margin-bottom-alt:auto'>Lines
71 to 78 are about projection. We do not need all columns in the selection. So
calling projection template function we specify list of columns we are
interested in:</p>

<p class=MsoNormal style='mso-margin-top-alt:auto;mso-margin-bottom-alt:auto'>boost::mpl::vector2&lt;name,name1&gt;</p>

<p class=MsoNormal style='mso-margin-top-alt:auto;mso-margin-bottom-alt:auto'>Line
70 stands for outputting result relation in stdout. Actually it iterates over
projection relation (which one can imagine as a virtual collection) and for
each tuple in the collection outputs each field that belong the tuple. See, we
do not specify the fields prints needs to print. The function deduces it from
the type of parameter. It is general idea if RTL: programmer does not need to
specify columns in a relation, compiler will do it itself.</p>

<p class=MsoNormal>It’s important to notice the following:</p>

<p class=MsoList2 style='mso-list:l2 level1 lfo5;mso-list-change:"%1\:1\:0\:\." "Dmitriy Arapov" 20021020T2133;
tab-stops:list .5in'><![if !supportLists]>1.<span style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
</span><![endif]>The structure of the table is defined inside the program,
which ensures it’s consistency with the program code;</p>

<p class=MsoList2 style='mso-list:l2 level1 lfo5;mso-list-change:"%1\:2\:0\:\." "Dmitriy Arapov" 20021020T2133;
tab-stops:list .5in'><![if !supportLists]>2.<span style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
</span><![endif]>All interfacing is done in C++, and strongly typed. If we
tried to use a wrong data type, table or column name, the compiler would
complain (although the messages current compilers provide tend to be huge and
difficult to read);</p>

<p class=MsoList2 style='mso-list:l2 level1 lfo5;mso-list-change:"%1\:3\:0\:\." "Dmitriy Arapov" 20021020T2133;
tab-stops:list .5in'><![if !supportLists]>3.<span style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
</span><![endif]>We can use not only fundamental types, such as EarthCoord.</p>

<h1><a name="_Toc68859939">Main Concepts</a></h1>

<p class=MsoNormal>The central concept of RTL is notion of <b>relation</b>. At
compile-time a relation forms an expression, which includes a relational operation
and operands, which are relations themselves. During run-time the relation can
be considered as a (virtual) collection of tuples, which can be iterated
through, like STL vector or list. Relation looks like a table, with fixed at
compile-time set of columns and changing during execution number of tuples. The
main idea behind RTL is to perform schema computations (that means establishing
number and types of columns, sort order, and candidate keys) for each relation
during compilation of the surrounding C++ application.</p>

<p class=MsoNormal><b>Columns</b> are identified by their names, which
internally are class names. Each column contains values of particular C++ type.
This type can be either C++ basic type, such as int or double, or a
user-defined class. This makes a major advantage over traditional DBMS, where
set of types is strictly limited. Please note, that the type of values stored
in a column (which we'll call for shortly &quot;column type&quot;) is not the
same as the class, used to identify the column. The requirements to a column
type are basically the same as requirements to a member of an STL container -
the class must be assignable, default-constructible, copy-constructible and if
the column participate in a sort order, it must have valid less functor. To
define a column RTL provides macro:</p>

<p class=MsoNormal>BOOST_RTL_DEFINE_COLUMN(type, name)</p>

<p class=MsoNormal>which takes two parameters: name of the column and type of
values it stores.</p>

<p class=MsoNormal>Columns are used to form column lists. <b>Column lists</b>
are MPL sequences of column (class) names. They are used to define tables’ fields,
sort order, and as template parameters for many relational operators.</p>

<p class=MsoNormal>A set of columns of a relation, which uniquely identifies a
tuple in the relations is called a <b>key</b>. All tuples in a relation have to
be distinct, so each relation has at least one key. However, a relation can
have more than one key. Each relation provides </p>

<p class=MsoNormal>typedef <i>unspecified</i> keys;</p>

<p class=MsoNormal>which lists all keys of a relation. User specifies keys for
tables. Other relations deduce their keys, from the argument keys. However, it
is not possible all times to deduce all keys, so user can explicitly add a key,
using pseudo-relation key_t. </p>

<p class=MsoNormal>Unlike in a pure relation theory all relations assumed to be
ordered. A column list named <b>sort_list</b> defines lexicographical order on
relation. Sort list always contains at least one key of the relation. Existence
of such order enables <b>binary search methods. </b>Each relation provides
three template methods: <span class=Inlinecode><span style='font-family:"Courier New";
mso-bidi-font-family:"Times New Roman"'>equal_range</span></span>, <span
class=Inlinecode><span style='font-family:"Courier New";mso-bidi-font-family:
"Times New Roman"'>lower_bound</span></span> and <span class=Inlinecode><span
style='font-family:"Courier New";mso-bidi-font-family:"Times New Roman"'>upper_bound</span></span>,
optimized for the search for all tuples, which are equal, greater or less than
a given (sub)tuple. </p>

<p class=MsoNormal><b>Tuples</b> (or rows) are collections of fields, one per
every column. They provide operations to access individual fields given the
column (class) name. A tuple exposes the <span class=Inlinecode><span
style='font-family:"Courier New";mso-bidi-font-family:"Times New Roman"'>field_list</span></span>
typedef. The field list is an MPL sequence, which contains all the columns
present in the tuple. </p>

<p class=MsoNormal><b>Iterators</b> are associated with each class of
relations. They allow iterate along the (virtual) collection of tuples. All
iterators are const_iterators, and do not allow to modify data inside relations.
Relational iterators are bi-directional iterators. </p>

<p class=MsoNormal><b>Tables</b> are relations, which are not virtual, but
physical collections of tuples. Tables model the relational table concept, as
well as provide means to maintain the collection. Tables provide insert, remove
and update operations. Tables are designed to be very compact to allow to be
passed around and stored by value. Instead of real collections they keep a
shared pointer to the table implementation.</p>

<p class=MsoNormal>Each relation is sorted by only one list of fields.<span
style="mso-spacerun: yes">  </span>If it is necessary to search using different
sort orders it is useful to create an <b>index</b>, which consists of same
tuples as its argument, but has a different sort order. Internally an index
uses table to store information about tuples ordering.</p>

<p class=MsoNormal style='mso-list:none;mso-list-change:\F0B7 "Dmitriy Arapov" 20021020T2133'><b>Table
implementations.</b> RTL does not follow “one size fits all” principle and
allows different implementations for different tables and indexes. Currently
default implementation is based on sorted STL vector. </p>

<h2><a name="_Toc68859940">Columns</a></h2>

<p class=MsoNormal>Columns are identified by a class name, which means that, in
order to declare a new column, one creates a new class.<span
style="mso-spacerun: yes">  </span>To do this, the <span style='font-family:
"Courier New"'>BOOST_RTL_DEFINE_COLUMN</span> macro should be used:</p>

<p class=Code>BOOST_RTL_DEFINE_COLUMN(int, ssn);</p>

<p class=Code>BOOST_RTL_DEFINE_COLUMN(std::string, name);</p>

<p class=Code>BOOST_RTL_DEFINE_COLUMN(int, salary);</p>

<p class=MsoNormal><br>
This declares a column named “name” with the value type of <span
class=Inlinecode><span style='font-family:"Courier New";mso-bidi-font-family:
"Times New Roman"'>std::string</span></span>.<span style="mso-spacerun: yes"> 
</span>Internally, the class <span class=Inlinecode><span style='font-family:
"Courier New";mso-bidi-font-family:"Times New Roman"'>name</span></span> is
created.</p>

<p class=MsoNormal>Since column names are class names, whenever column names
need to be passed around, they are passed as template parameters. Often columns
are combined in an MPL sequence, such as:</p>

<p class=Code>print(projection&lt;mpl::vector2&lt;name,
salary&gt;(staff_table));</p>

<p class=MsoNormal><br>
Note that one can easily define two columns of the same type. In this case, <span
class=Inlinecode><span style='font-family:"Courier New";mso-bidi-font-family:
"Times New Roman"'>ssn</span></span> and <span class=Inlinecode><span
style='font-family:"Courier New";mso-bidi-font-family:"Times New Roman"'>salary</span></span>
are two distinct classes that both denote a column of type int. Having two
columns with same name is prohibited.</p>

<h2><a name="_Toc68859941">Column Lists</a></h2>

<p class=MsoNormal>Column lists are used to form as <span class=Inlinecode><span
style='font-family:"Courier New";mso-bidi-font-family:"Times New Roman"'>FieldList</span></span>,
<span class=Inlinecode><span style='font-family:"Courier New";mso-bidi-font-family:
"Times New Roman"'>SortList</span></span> and as template parameters to many
relations.<span style="mso-spacerun: yes">  </span>The <span class=Inlinecode><span
style='font-family:"Courier New";mso-bidi-font-family:"Times New Roman"'>mpl::vector0&lt;&gt;</span></span>
class stands for an empty column list. </p>

<h2><a name="_Toc68859942">Tuples</a></h2>

<p class=MsoNormal>Once columns are defined they can be put together in a
tuple. The tuple class template is parameterized with a type-list of columns:</p>

<p class=Code>typedef mpl::vector3&lt;ssn, name, salary&gt; emploee_fields;</p>

<p class=Code>typedef row&lt;emploee_fields&gt; employee;</p>

<p class=MsoNormal><br>
Internally, the tuple class template is derived from every column in the
list.<span style="mso-spacerun: yes">  </span>We use a technique described in
[1]<span style="mso-spacerun: yes">  </span>as <span class=Inlinecode><span
style='font-family:"Courier New";mso-bidi-font-family:"Times New Roman"'>GenScatterHierarchy</span></span>
class. Note that these are columns, rather than their types, so fundamental
types are not a problem. The <span class=Inlinecode><span style='font-family:
"Courier New";mso-bidi-font-family:"Times New Roman"'>FieldList</span></span>
should contain no duplicates. This makes sense from both implementation
perspective (a class can’t be used twice as a base class), and interface
perspective (a column of given name should not be present more than once in a
tuple).</p>

<p class=MsoNormal style='mso-margin-top-alt:auto;mso-margin-bottom-alt:auto'>Since
a column is identified by the class name, the <span class=Inlinecode><span
style='font-family:"Courier New";mso-bidi-font-family:"Times New Roman"'>static_cast</span></span>
is used to access individual fields inside a tuple.<span style="mso-spacerun:
yes">  </span>To work around problems with explicit function template
instantiation, we use the notation that looks like following:</p>

<p class=Code>int s = tuple[salary()];</p>

<p class=MsoNormal><br>
We also defined a macro:</p>

<p class=Code>int s = BOOST_RTL_FIELD(tuple, salary);</p>

<h2><a name="_Toc68859943"><span style='color:black'>Tables</span></a><span
style='color:black'><o:p></o:p></span></h2>

<p class=MsoNormal><span style='color:black'>Tables are containers of tuples.
They model the relation concept and provide means to maintain the
collection.<span style="mso-spacerun: yes">  </span><o:p></o:p></span></p>

<p class=Code><span style='color:black'>template&lt;<o:p></o:p></span></p>

<p class=Code style='text-indent:.5in'><span style='color:black'>class
FieldList, <o:p></o:p></span></p>

<p class=Code style='text-indent:.5in'><span style='color:black'>class SortList
= FieldList,<o:p></o:p></span></p>

<p class=Code style='text-indent:.5in'><span style='color:black'>class KeyList
= mpl::vector1&lt;SortList&gt;, <o:p></o:p></span></p>

<p class=Code style='text-indent:.5in'><span style='color:black'>class
Implementation = sorted_strategy <o:p></o:p></span></p>

<p class=Code><span style='color:black'>&gt;<o:p></o:p></span></p>

<p class=Code><span style='color:black'>struct table_info<o:p></o:p></span></p>

<p class=Code><span style='color:black'>{<o:p></o:p></span></p>

<p class=Code><span style='color:black'><span style="mso-spacerun: yes">   
</span><span style='mso-tab-count:1'>  </span>typedef FieldList field_list;<o:p></o:p></span></p>

<p class=Code><span style='color:black'><span style="mso-spacerun: yes">   
</span><span style='mso-tab-count:1'>  </span>typedef SortList sort_list;<o:p></o:p></span></p>

<p class=Code><span style='color:black'><span style='mso-tab-count:1'>      </span>typedef
KeyList key_list;<o:p></o:p></span></p>

<p class=Code><span style='color:black'><span style="mso-spacerun: yes">   
</span><span style='mso-tab-count:1'>  </span>typedef Implementation
implementation;<o:p></o:p></span></p>

<p class=Code><span style='color:black'>};<o:p></o:p></span></p>

<p class=Code><span style='color:black'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=Code><span style='color:black'>template&lt;class Info&gt; class table;
<o:p></o:p></span></p>

<p class=MsoBodyText2><br>
First template parameter describes what columns are in the table. It is
mandatory. All other parameters are optional.<span style="mso-spacerun: yes"> 
</span><span class=Inlinecode><span style='font-family:"Courier New";
mso-bidi-font-family:"Times New Roman"'>SortList</span></span> defines the
order table is sorted. <span class=Inlinecode><span style='font-family:"Courier New";
mso-bidi-font-family:"Times New Roman"'>KeyList</span></span> defines which
sets of fields form keys, which can be used to uniquely identify a tuple.<span
style="mso-spacerun: yes">  </span><span class=Inlinecode><span
style='font-family:"Courier New";mso-bidi-font-family:"Times New Roman"'>Implementation</span></span>
codes the table implementation used. </p>

<p class=MsoNormal><span style='color:black'>Currently tables are the only
relations that provide </span><span class=Inlinecode><span style='font-family:
"Courier New";mso-bidi-font-family:"Times New Roman";color:black'>insert</span></span><span
style='color:black'>, </span><span class=Inlinecode><span style='font-family:
"Courier New";mso-bidi-font-family:"Times New Roman";color:black'>remove</span></span><span
style='color:black'> and </span><span class=Inlinecode><span style='font-family:
"Courier New";mso-bidi-font-family:"Times New Roman";color:black'>update</span></span><span
style='color:black'> operations. Despite tables aimed to hold data, they are
designed to be very compact -- instead of real collections they keep a
shared<span style="mso-spacerun: yes">  </span>pointer to the
table_implementation.<o:p></o:p></span></p>

<p class=MsoBodyText2>The template parameters to a table are combined in a
single structure<span class=Inlinecode><span style='font-family:"Courier New";
mso-bidi-font-family:"Times New Roman"'> table_info</span></span>. If
programmer creates a class, which inherits from the instance of <span
class=Inlinecode><span style='font-family:"Courier New";mso-bidi-font-family:
"Times New Roman"'>table_info </span></span>and use it as template parameter to
the <span class=Inlinecode><span style='font-family:"Courier New";mso-bidi-font-family:
"Times New Roman"'>table</span></span> template, one can<span class=Inlinecode><span
style='font-family:"Courier New";mso-bidi-font-family:"Times New Roman"'> </span></span>significantly
shorten template Ids used by a C++ compiler internally, thus making error
messages more readable and in case of MSVC 6.0 avoiding linking-time “duplicate
comdat” problem.</p>

<p class=Code><span style='color:black'>Struct employee_info : table_info <o:p></o:p></span></p>

<p class=Code><span style='color:black'>&lt;<o:p></o:p></span></p>

<p class=Code><span style='color:black'><span style='mso-tab-count:1'>      </span>emploee_fields,<o:p></o:p></span></p>

<p class=Code><span style='color:black'><span style='mso-tab-count:1'>      </span>mpl::vector1&lt;ssn&gt;
<o:p></o:p></span></p>

<p class=Code><span style='color:black'><span style='mso-tab-count:1'>      </span>//
we’ll use default KeyList and Implementation<o:p></o:p></span></p>

<p class=Code><span style='color:black'>&gt; {};<o:p></o:p></span></p>

<p class=Code><span style='color:black'>table&lt;employee_info&gt; employees;<o:p></o:p></span></p>

<p class=Code><span style='color:black'>typedef
table&lt;employee_info&gt;::value_type tup; // type of tuple;<o:p></o:p></span></p>

<p class=Code><span style='color:black'>employees.insert(tup(076567882, “Bill
Smith”, 100000));<o:p></o:p></span></p>

<p class=Code><span style='color:black'>employees.insert(tup(062888944, “John
Doe”, 85000));<o:p></o:p></span></p>

<p class=Code><span style='color:black'>print(employees);<o:p></o:p></span></p>

<h2><a name="_Toc68859944"></a><a name="_Toc10048139"><span style='mso-bookmark:
_Toc68859944'>Table implementations</span></a></h2>

<p class=MsoNormal><span style='mso-bookmark:_Toc10048139'>The library is
designed to allow for custom implementation of tables, which may be stored and
optimized in different ways. Say, sorted vector (the default implementation
provided with RTL) is a good way to implement tables that change rarely.
Set-like implementation may be better in case, when table changes frequently.
Disk-based implementation may be a good choice, if size of the table exceeds
main memory or persistence is an issue.</span></p>

<p class=MsoNormal><span style='mso-bookmark:_Toc10048139'>Table implementation
must be a class template parameterized with the type of tuple, which is used as
</span><span style='mso-bookmark:_Toc10048139'><span class=Inlinecode><span
style='font-family:"Courier New";mso-bidi-font-family:"Times New Roman"'>value_type</span></span>
of the implementation. A table implementation must provide </span><span
style='mso-bookmark:_Toc10048139'><span class=Inlinecode><span
style='font-family:"Courier New";mso-bidi-font-family:"Times New Roman"'>const_iterator</span></span>
(which expected to be bi-directional), methods </span><span style='mso-bookmark:
_Toc10048139'><span class=Inlinecode><span style='font-family:"Courier New";
mso-bidi-font-family:"Times New Roman"'>begin</span></span>, </span><span
style='mso-bookmark:_Toc10048139'><span class=Inlinecode><span
style='font-family:"Courier New";mso-bidi-font-family:"Times New Roman"'>end</span></span>,
</span><span style='mso-bookmark:_Toc10048139'><span class=Inlinecode><span
style='font-family:"Courier New";mso-bidi-font-family:"Times New Roman"'>size</span></span>,
</span><span style='mso-bookmark:_Toc10048139'><span class=Inlinecode><span
style='font-family:"Courier New";mso-bidi-font-family:"Times New Roman"'>reserve</span></span>,
</span><span style='mso-bookmark:_Toc10048139'><span class=Inlinecode><span
style='font-family:"Courier New";mso-bidi-font-family:"Times New Roman"'>insert</span></span>,
</span><span style='mso-bookmark:_Toc10048139'><span class=Inlinecode><span
style='font-family:"Courier New";mso-bidi-font-family:"Times New Roman"'>delete</span></span>
and </span><span style='mso-bookmark:_Toc10048139'><span class=Inlinecode><span
style='font-family:"Courier New";mso-bidi-font-family:"Times New Roman"'>update</span></span>,
template methods </span><span style='mso-bookmark:_Toc10048139'><span
class=Inlinecode><span style='font-family:"Courier New";mso-bidi-font-family:
"Times New Roman"'>equal_range</span></span>, </span><span style='mso-bookmark:
_Toc10048139'><span class=Inlinecode><span style='font-family:"Courier New";
mso-bidi-font-family:"Times New Roman"'>lower_bound</span></span> and </span><span
style='mso-bookmark:_Toc10048139'><span class=Inlinecode><span
style='font-family:"Courier New";mso-bidi-font-family:"Times New Roman"'>upper_bound</span></span>.
Methods </span><span style='mso-bookmark:_Toc10048139'><span class=Inlinecode><span
style='font-family:"Courier New";mso-bidi-font-family:"Times New Roman"'>begin</span></span>
and </span><span style='mso-bookmark:_Toc10048139'><span class=Inlinecode><span
style='font-family:"Courier New";mso-bidi-font-family:"Times New Roman"'>end</span></span>
must have const complexity; </span><span style='mso-bookmark:_Toc10048139'><span
class=Inlinecode><span style='font-family:"Courier New";mso-bidi-font-family:
"Times New Roman"'>size</span></span> and search group of methods must be not
worse than log(size).</span></p>

<p class=MsoNormal><span style='mso-bookmark:_Toc10048139'>A library user can
specify which implementation to use for any table or index.</span></p>

<h2><span style='mso-bookmark:_Toc10048139'><a name="_Toc68859945">Iterators</a></span></h2>

<p class=MsoNormal><span style='mso-bookmark:_Toc10048139'>There is an iterator
type associated with each class of relations. All iterators in RTL are </span><span
style='mso-bookmark:_Toc10048139'><span class=Inlinecode><span
style='font-family:"Courier New";mso-bidi-font-family:"Times New Roman"'>const_iterator</span></span>s,
because we treat all relations as constant objects. </span></p>

<p class=MsoNormal><span style='mso-bookmark:_Toc10048139'>All iterators are
bi-directional iterators. </span></p>

<p class=MsoNormal><span style='mso-bookmark:_Toc10048139'>All iterators have a
pointer to the operators they belong. To get this pointer use a method </span><span
style='mso-bookmark:_Toc10048139'><span class=Inlinecode><span
style='font-family:"Courier New";mso-bidi-font-family:"Times New Roman"'>relation()</span></span>.
Iterators of unary relations (such as </span><span style='mso-bookmark:_Toc10048139'><span
class=Inlinecode><span style='font-family:"Courier New";mso-bidi-font-family:
"Times New Roman"'>selection</span></span>) have also base relation’s iterator
as a member.<span style="mso-spacerun: yes">  </span>Iterators of binary
relations contain two iterators of base relations. Many iterators also keep some
additional data, required for calculations. So, unlike STL, RTL does not assume
all iteratators small. </span></p>

<p class=MsoNormal><span style='mso-bookmark:_Toc10048139'>In addition to
dereference operator*() RTL iterators provide template member get, which
returns value of single field of pointed tuple. This way it is possible to
avoid dereferencing big unused chunks of data.</span></p>

<h2><span style='mso-bookmark:_Toc10048139'><a name="_Toc68859946">Relations</a></span></h2>

<p class=MsoNormal>RTL defines relational operators, such as selection,
projection, cross-product, set operations, etc.</p>

<p class=MsoNormal>Relational operators are just template classes that model
the concept of a relation. This means a relation can be iterated through, used
as a (constant) parameter in an STL algorithm, or passed as an input to another
operator. To simplify the notation, each relation template class has an object
generator -- a template function, which creates an instance of the class. This
is similar to <span class=Inlinecode><span style='font-family:"Courier New";
mso-bidi-font-family:"Times New Roman"'>std::pair</span></span> and <span
class=Inlinecode><span style='font-family:"Courier New";mso-bidi-font-family:
"Times New Roman"'>std::make_pair</span></span>. Therefore one can type:</p>

<p class=Code>print(projection&lt;mpl::vector1&lt;c1&gt; &gt;(cross_product(t1,
t2)));</p>

<p class=MsoNormal><br>
instead of more tedious:</p>

<p class=Code>print(</p>

<p class=Code><span style="mso-spacerun: yes"> 
</span>projection_t&lt;cross_product_t&lt;table1_t, table2_t&gt;::type, mpl::vector&lt;c1&gt;
&gt;::type(</p>

<p class=Code><span style="mso-spacerun: yes">   
</span>cross_product_t&lt;table1_t, table2_t&gt;::type(t1, t2)));</p>

<p class=MsoNormal><br>
When a relation object is created, it stores the references to its arguments,
which may be either tables or other relational operators. </p>

<p class=MsoNormal>To be more comfortable with this, let’s take a look at what
happens when the following expression gets executed:</p>

<p class=Code>t1_type t1;</p>

<p class=Code>t2_type t2;</p>

<p class=Code>. . .</p>

<p class=Code>print(cross_product(t1, t2));</p>

<p class=MsoToc1><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></p>

<p class=MsoNormal style='margin-left:39.0pt;text-indent:-.25in;mso-list:l3 level1 lfo7;
mso-list-change:"%1\:1\:0\:\." "Dmitriy Arapov" 20021020T2133;tab-stops:list 39.0pt'><![if !supportLists]>1.<span
style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span><![endif]>The
<span class=Inlinecode><span style='font-family:"Courier New";mso-bidi-font-family:
"Times New Roman"'>cross_product</span></span> function template deduces its
template parameters using types of actual parameters, and creates a temporary
object of the type <span class=Inlinecode><span style='font-family:"Courier New";
mso-bidi-font-family:"Times New Roman"'>cross_product_t&lt;t1_type,
t2_type&gt;::type</span></span>.<span style="mso-spacerun: yes">  </span>This
object stores pointers to its parameters <span class=Inlinecode><span
style='font-family:"Courier New";mso-bidi-font-family:"Times New Roman"'>t1</span></span>
and <span class=Inlinecode><span style='font-family:"Courier New";mso-bidi-font-family:
"Times New Roman"'>t2</span></span>.<span style="mso-spacerun: yes">  </span></p>

<p class=MsoNormal style='margin-left:39.0pt;text-indent:-.25in;mso-list:l3 level1 lfo7;
mso-list-change:"%1\:2\:0\:\." "Dmitriy Arapov" 20021020T2133;tab-stops:list 39.0pt'><![if !supportLists]>2.<span
style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span><![endif]>The
cross-product temporary object is passed to the <span class=Inlinecode><span
style='font-family:"Courier New";mso-bidi-font-family:"Times New Roman"'>print </span></span>function.</p>

<p class=MsoNormal style='margin-left:39.0pt;text-indent:-.25in;mso-list:l3 level1 lfo7;
mso-list-change:"%1\:3\:0\:\." "Dmitriy Arapov" 20021020T2133;tab-stops:list 39.0pt'><![if !supportLists]>3.<span
style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span><![endif]>The
<span class=Inlinecode><span style='font-family:"Courier New";mso-bidi-font-family:
"Times New Roman"'>print</span></span> function calls <span class=Inlinecode><span
style='font-family:"Courier New";mso-bidi-font-family:"Times New Roman"'>begin()</span></span>
on the cross-product.<span style="mso-spacerun: yes">  </span>The <span
class=Inlinecode><span style='font-family:"Courier New";mso-bidi-font-family:
"Times New Roman"'>begin()</span></span> creates a <span class=Inlinecode><span
style='font-family:"Courier New";mso-bidi-font-family:"Times New Roman"'>const_iterator</span></span>
(actually this means <span class=Inlinecode><span style='font-family:"Courier New";
mso-bidi-font-family:"Times New Roman"'>cross_product_iterator&lt;t1_type,
t2_type&gt;</span></span>), initialized with <span class=Inlinecode><span
style='font-family:"Courier New";mso-bidi-font-family:"Times New Roman"'>t1.begin(),t2.begin()</span></span>and
<span class=Inlinecode><span style='font-family:"Courier New";mso-bidi-font-family:
"Times New Roman"'>this</span></span> pointer.</p>

<p class=MsoNormal style='margin-left:39.0pt;text-indent:-.25in;mso-list:l3 level1 lfo7;
mso-list-change:"%1\:4\:0\:\." "Dmitriy Arapov" 20021020T2133;tab-stops:list 39.0pt'><![if !supportLists]>4.<span
style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span><![endif]><span
class=Inlinecode><span style='font-family:"Courier New";mso-bidi-font-family:
"Times New Roman"'>print</span></span> de-references the <span
class=Inlinecode><span style='font-family:"Courier New";mso-bidi-font-family:
"Times New Roman"'>cross_product_iterator</span></span>.<span
style="mso-spacerun: yes">  </span><span class=Inlinecode><span
style='font-family:"Courier New";mso-bidi-font-family:"Times New Roman"'>operator*()</span></span>
of the <span class=Inlinecode><span style='font-family:"Courier New";
mso-bidi-font-family:"Times New Roman"'>cross_product_iterator</span></span> de-references
the <span class=Inlinecode><span style='font-family:"Courier New";mso-bidi-font-family:
"Times New Roman"'>const_iterator</span></span>s of <span class=Inlinecode><span
style='font-family:"Courier New";mso-bidi-font-family:"Times New Roman"'>t1</span></span>
and <span class=Inlinecode><span style='font-family:"Courier New";mso-bidi-font-family:
"Times New Roman"'>t2</span></span>, and combines them in a new cross-product
tuple, which is returned.</p>

<p class=MsoNormal style='margin-left:39.0pt;text-indent:-.25in;mso-list:l3 level1 lfo7;
mso-list-change:"%1\:5\:0\:\." "Dmitriy Arapov" 20021020T2133;tab-stops:list 39.0pt'><![if !supportLists]>5.<span
style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span><![endif]><span
class=Inlinecode><span style='font-family:"Courier New";mso-bidi-font-family:
"Times New Roman"'>print</span></span> prints the tuple, performing same output
operation for each filed of the tuple.</p>

<p class=MsoNormal style='margin-left:39.0pt;text-indent:-.25in;mso-list:l3 level1 lfo7;
mso-list-change:"%1\:6\:0\:\." "Dmitriy Arapov" 20021020T2133;tab-stops:list 39.0pt'><![if !supportLists]>6.<span
style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span><![endif]><span
class=Inlinecode><span style='font-family:"Courier New";mso-bidi-font-family:
"Times New Roman"'>print</span></span> increments the cross-product iterator.</p>

<p class=MsoNormal style='margin-left:39.0pt;text-indent:-.25in;mso-list:l3 level1 lfo7;
mso-list-change:"%1\:7\:0\:\." "Dmitriy Arapov" 20021020T2133;tab-stops:list 39.0pt'><![if !supportLists]>7.<span
style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span><![endif]><span
class=Inlinecode><span style='font-family:"Courier New";mso-bidi-font-family:
"Times New Roman"'>operator++()</span></span> of the cross-product iterator
increments the iterator of <span class=Inlinecode><span style='font-family:
"Courier New";mso-bidi-font-family:"Times New Roman"'>t2</span></span>.<span
style="mso-spacerun: yes">  </span>If it reaches <span class=Inlinecode><span
style='font-family:"Courier New";mso-bidi-font-family:"Times New Roman"'>t2.end()</span></span>,
it is reset to <span class=Inlinecode><span style='font-family:"Courier New";
mso-bidi-font-family:"Times New Roman"'>t2.begin()</span></span> and the
iterator of <span class=Inlinecode><span style='font-family:"Courier New";
mso-bidi-font-family:"Times New Roman"'>t1</span></span> is incremented. When
it reaches <span class=Inlinecode><span style='font-family:"Courier New";
mso-bidi-font-family:"Times New Roman"'>t1.end()</span></span>, we are done.
Otherwise we keep looping.</p>

<p class=MsoNormal>The above description means that the relations are virtual
collections and they don’t materialize tuples they consist of right away.
Instead, resulting tuples are constructed on the fly. This technique lets us to
avoid storing intermediate results.</p>

<p class=MsoNormal>RTL implements unary and binary relational operators.</p>

<p class=MsoNormal>As all STL containers do, all relations provide 2 functions <span
class=Inlinecode><span style='font-family:"Courier New";mso-bidi-font-family:
"Times New Roman"'>begin</span></span> and <span class=Inlinecode><span
style='font-family:"Courier New";mso-bidi-font-family:"Times New Roman"'>end</span></span>,
to instantiate their <span class=Inlinecode><span style='font-family:"Courier New";
mso-bidi-font-family:"Times New Roman"'>const_iterator</span></span>s. </p>

<p class=MsoNormal>Each relation also provides three template methods: <span
class=Inlinecode><span style='font-family:"Courier New";mso-bidi-font-family:
"Times New Roman"'>equal_range</span></span>, <span class=Inlinecode><span
style='font-family:"Courier New";mso-bidi-font-family:"Times New Roman"'>lower_bound</span></span>
and <span class=Inlinecode><span style='font-family:"Courier New";mso-bidi-font-family:
"Times New Roman"'>upper_bound</span></span>, optimized for search of all
tuples which are equal, greater or less than a given (sub)tuple.</p>

<p class=Code>template&lt;class SubTuple&gt;</p>

<p class=Code><span style='mso-tab-count:1'>      </span>range_t&lt;const_iterator&gt;
equal_range(const SubTuple&amp; sub) const;</p>

<p class=Code>template&lt;class SubTuple&gt;</p>

<p class=Code><span style='mso-tab-count:1'>      </span>const_iterator
lower_bound(const SubTuple&amp; sub) const;</p>

<p class=Code>template&lt;class SubTuple&gt;</p>

<p class=Code><span style='mso-tab-count:1'>      </span>const_iterator
upper_bound(const SubTuple&amp; sub) const;</p>

<p class=MsoNormal><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></p>

<p class=MsoNormal>While <span class=Inlinecode><span style='font-family:"Courier New";
mso-bidi-font-family:"Times New Roman"'>lower_bound</span></span> and <span
class=Inlinecode><span style='font-family:"Courier New";mso-bidi-font-family:
"Times New Roman"'>upper_bound</span></span> methods return <span
class=Inlinecode><span style='font-family:"Courier New";mso-bidi-font-family:
"Times New Roman"'>const_iterator</span></span>, <span class=Inlinecode><span
style='font-family:"Courier New";mso-bidi-font-family:"Times New Roman"'>equal_range</span></span>
returns <span class=Inlinecode><span style='font-family:"Courier New";
mso-bidi-font-family:"Times New Roman"'>range_t&lt;const_iterator&gt;</span></span>,
which is more than just a pair of iterators.<span style="mso-spacerun: yes"> 
</span>It is a first-class relation, which can be used anywhere a relation is
allowed.</p>

<p class=MsoNormal>For each relation class (except tables) RTL defines a
function that creates an object of this class.<span style="mso-spacerun: yes"> 
</span>Please note that the order of template parameters of the class and of
the function may be different.<span style="mso-spacerun: yes">  </span>In the
case of functions, all template parameters which can de deduced from types of
actual parameters of the template function, go after other template parameters.</p>

<h3><a name="_Toc68859947">selection</a></h3>

<p class=MsoNormal>Selection is a unary relation. As every unary relational
operator it takes one relation as a parameter.<span style="mso-spacerun: yes"> 
</span>In addition it accepts a predicate that determines which tuples to
select. </p>

<p class=Code>template&lt;class Pred, class Table&gt; </p>

<p class=Code style='text-indent:.5in'>selection_t&lt;Table,Pred&gt;::type
selection(const Table&amp; t, Pred p);</p>

<p class=MsoNormal><br>
The predicate should be defined in the same way one would do it for the
std::find_if() algorithm.</p>

<p class=MsoNormal>Example: Let us model the following SQL statement:</p>

<p class=Code>SELECT * FROM emploees WHERE position = “manager” AND salary &gt;
100000;</p>

<p class=MsoNormal><br>
With RTL it can be coded as:</p>

<p class=Code>table&lt;employee_info&gt; employees;</p>

<p class=Code>bool pred(const table&lt;employee_info&gt;::value_type&amp; e)</p>

<p class=Code>{</p>

<p class=Code><span style="mso-spacerun: yes">  </span>return e[position()] !=
“manager” &amp;&amp; e[salary()] &gt; 100000;</p>

<p class=Code>}</p>

<p class=Code>. . .</p>

<p class=Code>print(</p>

<p class=Code style='text-indent:.5in'>selection(employees, pred)</p>

<p class=Code>);</p>

<p class=MsoNormal><br>
It is possible to use Boost.Lambda to create functors for the selection
operator.<span style="mso-spacerun: yes">  </span>The lambda functor that
extracts field “some_field” from the current row would look as following:</p>

<p class=Code>lambda::_1[some_field()];</p>

<p class=MsoNormal><br>
With the help of lambda the above example can be re-written like this:</p>

<p class=Code>table&lt;employee&gt; employees;</p>

<p class=Code>. . .</p>

<p class=Code>print(</p>

<p class=Code style='text-indent:.5in'>selection(employees, _1[position()] !=
“manager” &amp;&amp; _1[salary()] &gt; 100000)</p>

<p class=Code>);</p>

<p class=MsoBodyText><br>
This usage is fine as long as only temporary expression is required.<span
style="mso-spacerun: yes">  </span>If one needs to allocate an object of this
selection type, the type of the selection, and therefore the type of the
functor need to be specified (at least until the typeof operator becomes
available in C++).<span style="mso-spacerun: yes">  </span>In this case
Boost.Function proves handy (although using it involves some indirection
overhead):<br style='mso-special-character:line-break'>
<![if !supportLineBreakNewLine]><br style='mso-special-character:line-break'>
<![endif]></p>

<p class=Code>table&lt;employee&gt; employees;</p>

<p class=Code>. . .</p>

<p class=Code>typedef function&lt;bool(table&lt;employee&gt;::value_type)&gt; function_type;</p>

<p class=Code><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></p>

<p class=Code>selection_t&lt;table&lt;employee&gt;, function_type&gt; sel = </p>

<p class=Code><span style="mso-spacerun: yes">    </span>selection(employees,
function_type(_1[position()] != “manager” &amp;&amp; _1[salary()] &gt;
100000)); </p>

<p class=Code><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></p>

<p class=Code>print(sel);</p>

<h3><a name="_Toc68859948">projection</a></h3>

<p class=MsoNormal>Projection is also a unary relational operator. In addition
to its relation argument it accepts a type-list of columns, which should be
included in the resulting relation. </p>

<p class=Code>template&lt; class FieldList, class Table&gt; </p>

<p class=Code style='text-indent:.5in'>projection_t&lt;Table,FieldList&gt;::type
projection(const Table&amp; t);</p>

<p class=MsoNormal><b><br>
Example.</b> Consider the following SQL statement:</p>

<p class=Code>SELECT name,salary FROM emploees;</p>

<p class=MsoNormal><br>
It can be coded with RTL like this: </p>

<p class=Code>table&lt;employee&gt; employees;</p>

<p class=Code>. . .</p>

<p class=Code>print(</p>

<p class=Code style='text-indent:.5in'>projection&lt;mpl::vector2&lt;name,
salary&gt; &gt;(employees)</p>

<p class=Code>);</p>

<h3><a name="_Toc68859949">cross_product</a></h3>

<p class=MsoNormal>Cross_product is a binary relation. It consists of all
possible combinations of tuples from the first and second relations. </p>

<p class=Code>template&lt;class Table1, class Table2&gt; </p>

<p class=Code style='text-indent:.5in'>cross_product_t&lt;Table1,Table2&gt;::type
cross_product(</p>

<p class=Code style='text-indent:.5in'><span style="mso-spacerun: yes"> </span><span
style='mso-tab-count:1'>     </span>const Table1&amp; t1,</p>

<p class=Code style='text-indent:.5in'><span style='mso-tab-count:1'>      </span>const
Table2&amp; t2</p>

<p class=Code style='text-indent:.5in'>);</p>

<p class=MsoNormal><br>
Columns in Table1 and Table2 must have different names, if some of them have
same name one of <span class=Inlinecode><span style='font-family:"Courier New";
mso-bidi-font-family:"Times New Roman"'>rename</span></span> relational
operators should be applied first.</p>

<p class=MsoNormal>The <span class=Inlinecode><span style='font-family:"Courier New";
mso-bidi-font-family:"Times New Roman"'>cross_product</span></span> can be used
as following:</p>

<p class=Code>print(</p>

<p class=Code style='text-indent:.5in'>cross_product(t1, t2)</p>

<p class=Code>);</p>

<h3><a name="_Toc68859950">extension</a></h3>

<p class=MsoNormal>This is a unary operator that adds columns to its
parameters.<span style="mso-spacerun: yes">  </span>Users have to define a
policy, where they specify which fields to add, and how these fields are
calculated.<span style="mso-spacerun: yes">  </span>This feature substitutes
the previously used “calculated fields”.</p>

<p class=Code>template&lt;class Table, class Policy&gt;</p>

<p class=Code><span style="mso-spacerun: yes">  </span>typename
extension_t&lt;Table, Policy&gt;::type </p>

<p class=Code><span style="mso-spacerun: yes">    </span>extension(const
Table&amp; t, const Policy&amp; p);</p>

<p class=MsoNormal><br>
Let’s say there is a table of integers:</p>

<p class=Code>BOOST_RTL_DEFINE_COLUMN(int, c1);</p>

<p class=Code>struct my_info : table_info&lt;mpl::vector1&lt;c1&gt; &gt; {};</p>

<p class=Code>typedef table&lt;my_info&gt; my_table;</p>

<p class=MsoNormal><br>
First the new column has to be defined:</p>

<p class=Code>BOOST_RTL_DEFINE_COLUMN(int, c2);</p>

<p class=MsoNormal><br>
If we want c2 to be the square of c1, the policy should look something like
following:</p>

<p class=Code>struct extender</p>

<p class=Code>{</p>

<p class=Code><span style='mso-tab-count:1'>      </span>typedef
mpl::vector&lt;c2&gt; field_list;</p>

<p class=Code><span style='mso-tab-count:1'>      </span></p>

<p class=Code><span style='mso-tab-count:1'>      </span>template&lt;class
It&gt;</p>

<p class=Code><span style='mso-tab-count:2'>            </span>int get(const
It&amp; it, const c2&amp;) const</p>

<p class=Code><span style='mso-tab-count:1'>      </span>{</p>

<p class=Code><span style='mso-tab-count:2'>            </span>return
it.get(c1()) * it.get(c1()); </p>

<p class=Code><span style='mso-tab-count:1'>      </span>}</p>

<p class=Code>};</p>

<p class=MsoNormal style='margin-bottom:0in;margin-bottom:.0001pt;mso-layout-grid-align:
none;text-autospace:none'><span style='font-size:10.0pt;font-family:"Courier New"'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=MsoNormal>The call now looks like this:</p>

<p class=Code>my_table t;</p>

<p class=Code>. . .</p>

<p class=Code>print(</p>

<p class=Code style='text-indent:.5in'>extension(t, extender())</p>

<p class=Code>);</p>

<h3><a name="_Toc68859951">Set operations</a></h3>

<p class=MsoNormal>Following three relations are very similar. All of them take
2 relational parameters and require the parameters have the same <span
class=Inlinecode><span style='font-family:"Courier New";mso-bidi-font-family:
"Times New Roman"'>value_type</span></span>. To understand the set operations
it is very important to understand, how we compare tuples. We say, that tuples
in two relations are same, if all fields from their sort_lists are equivalent.</p>

<h3><a name="_Toc68859952">difference</a></h3>

<p class=MsoNormal>Difference is a binary relation. It contains all tuples,
which belong to the first and do not belong to the second operand:</p>

<p class=Code>template&lt;class Table1, class Table2&gt; </p>

<p class=Code style='text-indent:.5in'>difference_t&lt;Table1,Table2&gt;::type
difference(</p>

<p class=Code style='text-indent:.5in'><span style="mso-spacerun: yes"> </span><span
style='mso-tab-count:1'>     </span>const Table1&amp; t1,</p>

<p class=Code style='text-indent:.5in'><span style='mso-tab-count:1'>      </span>const
Table2&amp; t2</p>

<p class=Code style='text-indent:.5in'>);</p>

<p class=MsoNormal><br>
It requires that both its arguments have the same tuple type.<span
style="mso-spacerun: yes">  </span>It can be used as following:</p>

<p class=Code>print(</p>

<p class=Code style='text-indent:.5in'>difference(t1, t2)</p>

<p class=Code>);</p>

<h3><a name="_Toc68859953">diff</a></h3>

<p class=MsoNormal>This is another difference, optimized for the case where the
first argument is much smaller then the second one:</p>

<p class=Code>template&lt;class Table1, class Table2&gt;</p>

<p class=Code><span style='mso-tab-count:1'>      </span>typename
diff_t&lt;Table1, Table2&gt;::type </p>

<p class=Code><span style='mso-tab-count:2'>            </span>diff(const
Table1&amp; t1, const Table2&amp; t2);</p>

<h3><a name="_Toc68859954">Union</a></h3>

<p class=MsoNormal>Union is a binary relation. It contains all tuples, which
belong to either the first, or the second operand. In case of two equivalent
tuples the operation uses tuple from 1<sup>st</sup> operand.</p>

<p class=Code>template&lt;class Table1, class Table2&gt; </p>

<p class=Code style='text-indent:.5in'>union_t&lt;Table1,Table2&gt;::type
Union(</p>

<p class=Code style='text-indent:.5in'><span style="mso-spacerun: yes"> </span><span
style='mso-tab-count:1'>     </span>const Table1&amp; t1,</p>

<p class=Code style='text-indent:.5in'><span style='mso-tab-count:1'>      </span>const
Table2&amp; t2</p>

<p class=Code style='text-indent:.5in'>);</p>

<p class=MsoNormal><br>
It can be used as following:</p>

<p class=Code>print(</p>

<p class=Code style='text-indent:.5in'>Union(t1, t2)</p>

<p class=Code>);</p>

<p class=MsoNormal><br>
Please note the use of the capital “U”.<span style="mso-spacerun: yes"> 
</span>This is done to avoid the conflict with the C++ keyword.</p>

<h3><a name="_Toc68859955">intersection</a></h3>

<p class=MsoNormal>Intersection is a binary operator. It contains all tuples,
which belong to both operands, it always takes tuple from 1<sup>st</sup>
operand.</p>

<p class=Code>template&lt;class Table1, class Table2&gt; </p>

<p class=Code style='text-indent:.5in'>intersection_t&lt;Table1,Table2&gt;::type
intersection (</p>

<p class=Code style='text-indent:.5in'><span style="mso-spacerun: yes"> </span><span
style='mso-tab-count:1'>     </span>const Table1&amp; t1,</p>

<p class=Code style='text-indent:.5in'><span style='mso-tab-count:1'>      </span>const
Table2&amp; t2</p>

<p class=Code style='text-indent:.5in'>);</p>

<p class=MsoNormal><br>
It can be used as following:</p>

<p class=Code>print(</p>

<p class=Code style='text-indent:.5in'>intersection(t1, t2)</p>

<p class=Code>);</p>

<h3><a name="_Toc68859956"></a><a name="_Toc10048146"><span style='mso-bookmark:
_Toc68859956'>isection</span></a></h3>

<p class=MsoNormal><span style='mso-bookmark:_Toc10048146'>This is another
intersection, optimized for the case where the first argument is much smaller
then the second one. Result always use tuple from 1<sup>st</sup> operand:</span></p>

<p class=Code><span style='mso-bookmark:_Toc10048146'>template&lt;class Table1,
class Table2&gt;</span></p>

<p class=Code><span style='mso-bookmark:_Toc10048146'><span
style="mso-spacerun: yes">    </span>typename
isection_t&lt;Table1,Table2&gt;::type </span></p>

<p class=Code><span style='mso-bookmark:_Toc10048146'><span
style="mso-spacerun: yes">        </span>isection(const Table1&amp; t1, const
Table2&amp; t2);</span></p>

<h3><span style='mso-bookmark:_Toc10048146'><a name="_Toc68859957">rsection</a></span></h3>

<p class=MsoNormal><span style='mso-bookmark:_Toc10048146'>This is yet another
intersection, optimized for the case where the first argument is much smaller
then the second one. Result always use tuple from 2<sup>st</sup> operand:</span></p>

<p class=Code><span style='mso-bookmark:_Toc10048146'>template&lt;class Table1,
class Table2&gt;</span></p>

<p class=Code><span style='mso-bookmark:_Toc10048146'><span
style="mso-spacerun: yes">    </span>typename
rsection_t&lt;Table1,Table2&gt;::type </span></p>

<p class=Code><span style='mso-bookmark:_Toc10048146'><span
style="mso-spacerun: yes">        </span>rsection(const Table1&amp; t1, const
Table2&amp; t2);</span></p>

<h3><span style='mso-bookmark:_Toc10048146'><br>
<a name="_Toc68859958">range</a></span></h3>

<p class=MsoNormal>Range is a relation, which takes as a parameter not another
relation, but two const_iterators, which mark a range in a relation. Range is a
template class with associated <span class=Inlinecode><span style='font-family:
"Courier New";mso-bidi-font-family:"Times New Roman"'>const_iterator</span></span>.<span
style="mso-spacerun: yes">  </span>Its <span class=Inlinecode><span
style='font-family:"Courier New";mso-bidi-font-family:"Times New Roman"'>begin()</span></span>
method returns its first operand, and its <span class=Inlinecode><span
style='font-family:"Courier New";mso-bidi-font-family:"Times New Roman"'>end()</span></span>
method returns the second operand. </p>

<p class=Code><span style='font-family:Courier'>template&lt;class Iter&gt;
range_t&lt;Iter&gt; range(Iter begin, Iter end);<o:p></o:p></span></p>

<p class=Code><span style='font-family:Courier'>template&lt;class Iter&gt;
range_t&lt;Iter&gt; range(Iter i);<o:p></o:p></span></p>

<p class=MsoNormal><br>
The form of the <span class=Inlinecode><span style='font-family:"Courier New";
mso-bidi-font-family:"Times New Roman"'>range </span></span>function with one
parameter creates a range that consists of only one tuple (note, the end iterator
is not valid as an input value).</p>

<p class=MsoNormal>Each relation has <span class=Inlinecode><span
style='font-family:"Courier New";mso-bidi-font-family:"Times New Roman"'>equal_range</span></span>
template method, which returns an object of class <span class=Inlinecode><span
style='font-family:"Courier New";mso-bidi-font-family:"Times New Roman"'>range_t</span></span>.</p>

<h3><a name="_Toc68859959">range_selection</a></h3>

<p class=MsoNormal><span class=Inlinecode><span style='font-family:"Courier New";
mso-bidi-font-family:"Times New Roman"'>range_selection</span></span> allows
you define a range of tuples.<span style="mso-spacerun: yes">  </span>Unlike <span
class=Inlinecode><span style='font-family:"Courier New";mso-bidi-font-family:
"Times New Roman"'>range</span></span>, rather than storing its <span
class=Inlinecode><span style='font-family:"Courier New";mso-bidi-font-family:
"Times New Roman"'>begin/end</span></span> iterators, <span class=Inlinecode><span
style='font-family:"Courier New";mso-bidi-font-family:"Times New Roman"'>range_selection</span></span>
calls one function each time <span class=Inlinecode><span style='font-family:
"Courier New";mso-bidi-font-family:"Times New Roman"'>begin</span></span>, and
another function each time <span class=Inlinecode><span style='font-family:
"Courier New";mso-bidi-font-family:"Times New Roman"'>end</span></span> is
called.</p>

<p class=MsoNormal>Since this operator doesn’t store iterators, it is compliant
with transactions’ incremental update facility described below (<span
class=Inlinecode><span style='font-family:"Courier New";mso-bidi-font-family:
"Times New Roman"'>range</span></span> is not).</p>

<p class=Code>template&lt;class Table, class Begin, class End&gt;</p>

<p class=Code style='text-indent:.5in'>typename range_selection_t&lt;Table,
Begin, End&gt;::type </p>

<p class=Code style='text-indent:.5in'>range_selection(const Table&amp; t,
const Begin&amp; b, const End&amp; e);</p>

<p class=MsoNormal><br>
The <span class=Inlinecode><span style='font-family:"Courier New";mso-bidi-font-family:
"Times New Roman"'>Begin</span></span> and <span class=Inlinecode><span
style='font-family:"Courier New";mso-bidi-font-family:"Times New Roman"'>End</span></span>
template parameters are functors, that are later used when <span
class=Inlinecode><span style='font-family:"Courier New";mso-bidi-font-family:
"Times New Roman"'>begin/end</span></span> is called. There are four
pre-defined functors:</p>

<p class=Code>struct begin;</p>

<p class=Code>struct end;</p>

<p class=Code>template&lt;class Sub&gt;</p>

<p class=Code><span style='mso-tab-count:1'>      </span>lower_bound_t&lt;Sub&gt;
lower_bound(const Sub&amp; sub);</p>

<p class=Code>template&lt;class Sub&gt;</p>

<p class=Code><span style='mso-tab-count:1'>      </span>upper_bound_t&lt;Sub&gt;
upper_bound(const Sub&amp; sub);</p>

<p class=MsoNormal><br>
<span class=Inlinecode><span style='font-family:"Courier New";mso-bidi-font-family:
"Times New Roman"'>Sub</span></span> has to be a prefix of the <span
class=Inlinecode><span style='font-family:"Courier New";mso-bidi-font-family:
"Times New Roman"'>sort_list</span></span>.</p>

<p class=MsoNormal>One can use <span class=Inlinecode><span style='font-family:
"Courier New";mso-bidi-font-family:"Times New Roman"'>range_selection</span></span>
like this:</p>

<p class=Code>print(</p>

<p class=Code style='text-indent:.5in'>range_selection(t,
lower_bound(tuple_t(3)), upper_bound(tuple_t(5)))</p>

<p class=Code>);</p>

<p class=Code>print(</p>

<p class=Code style='text-indent:.5in'>range_selection(t, begin,
upper_bound(tuple_t(5)))</p>

<p class=Code>);</p>

<p class=Code>assert(equal_tables(t, range_selection(t, begin, end)));</p>

<h3><a name="_Toc68859960">equal_selection</a></h3>

<p class=MsoNormal>This is range_selections optimized for the case of equal
range:</p>

<p class=Code>template&lt;class Table, class Sub&gt; </p>

<p class=Code><span style='mso-tab-count:1'>      </span>typename
equal_selection_t&lt;Table, Sub&gt;::type equal_selection(const Table&amp; t,
const Sub&amp; sub);</p>

<p class=MsoNormal><br>
<span class=Inlinecode><span style='font-family:"Courier New";mso-bidi-font-family:
"Times New Roman"'>Sub</span></span> has to be a prefix of the <span
class=Inlinecode><span style='font-family:"Courier New";mso-bidi-font-family:
"Times New Roman"'>sort_list</span></span>.</p>

<h3><a name="_Toc68859961">range_join</a></h3>

<p class=MsoNormal>This operator walks through its outer relation (first
argument), and, for each tuple in it, creates a range on the inner relation
(second argument).<span style="mso-spacerun: yes">  </span>How exactly the
range is created, is defined by two functors (supplied as two additional
arguments), which specify how to locate the beginning and the end of the range,
respectively.</p>

<p class=Code>template&lt;class Table1, class Table2, class Begin, class
End&gt;</p>

<p class=Code style='text-indent:.5in'>typename range_join_t&lt;Table1, Table2,
Begin, End&gt;::type</p>

<p class=Code style='text-indent:.5in'>range_join(const Table1&amp; t1, const
Table2&amp; t2, const Begin&amp; b, const End&amp; e)</p>

<p class=MsoNormal><br>
RTL supplies four pre-defined range functors (located in <span
class=Inlinecode><span style='font-family:"Courier New";mso-bidi-font-family:
"Times New Roman"'>range_functors.hpp</span></span>):</p>

<p class=Code>struct begin;</p>

<p class=Code>struct end;</p>

<p class=Code><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></p>

<p class=Code>template&lt;class FieldList&gt; class lower_bound_t;</p>

<p class=Code>template&lt;class FieldList&gt; lower_bound_t&lt;FieldList&gt;
lower_bound();</p>

<p class=Code><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></p>

<p class=Code>template&lt;class FieldList&gt; class upper_bound_t;</p>

<p class=Code>template&lt;class FieldList&gt; upper_bound_t&lt;FieldList&gt;
upper_bound();</p>

<p class=MsoNormal><br>
The begin/end functors specify that the begin/end of the inner relation have to
be located on the inner relation.<span style="mso-spacerun: yes">  </span>For
example the cross_product operator is defined through the <span
class=Inlinecode><span style='font-family:"Courier New";mso-bidi-font-family:
"Times New Roman"'>range_join</span></span> as following:</p>

<p class=Code>template &lt;class Table1, class Table2&gt;</p>

<p class=Code style='text-indent:.5in'>struct cross_product_t :
range_join_t&lt;Table1, Table2, begin, end&gt;</p>

<p class=Code>{};</p>

<p class=MsoNormal><br>
The <span class=Inlinecode><span style='font-family:"Courier New";mso-bidi-font-family:
"Times New Roman"'>lower_bound</span></span> functor is parameterized with the
field list.<span style="mso-spacerun: yes">  </span>These fields get extracted
from the current tuple in the outer relation, and the resulting sub-tuple is
used to execute <span class=Inlinecode><span style='font-family:"Courier New";
mso-bidi-font-family:"Times New Roman"'>lower_bound</span></span> on the inner
relation.<span style="mso-spacerun: yes">  </span>The <span class=Inlinecode><span
style='font-family:"Courier New";mso-bidi-font-family:"Times New Roman"'>upper_bound</span></span>
is similar. </p>

<p class=MsoNormal>For example, the <span class=Inlinecode><span
style='font-family:"Courier New";mso-bidi-font-family:"Times New Roman"'>equal_join</span></span>
is defined through the <span class=Inlinecode><span style='font-family:"Courier New";
mso-bidi-font-family:"Times New Roman"'>range_join</span></span> as following:</p>

<p class=Code>template&lt;class T1, class T2, class FieldList&gt;</p>

<p class=Code style='text-indent:.5in'>struct equal_join_t :
range_join_t&lt;T1, T2, lower_bound_t&lt;FieldList&gt;,
upper_bound_t&lt;FieldList&gt; &gt;</p>

<p class=Code>{};</p>

<p class=MsoNormal><br>
The <span class=Inlinecode><span style='font-family:"Courier New";mso-bidi-font-family:
"Times New Roman"'>FieldList</span></span> template parameter here specifies
which fields to get from the current tuple in the outer relation to locate the
equal range on the inner relation. </p>

<p class=MsoNormal><b>Example</b>: let’s model the following SQL statement:</p>

<p class=Code>select * from t1, t2 where t1.c1 = t2.c2</p>

<p class=MsoNormal><br>
Suppose <span class=Inlinecode><span style='font-family:"Courier New";
mso-bidi-font-family:"Times New Roman"'>t2</span></span> is sorted on <span
class=Inlinecode><span style='font-family:"Courier New";mso-bidi-font-family:
"Times New Roman"'>c2</span></span>.<span style="mso-spacerun: yes"> 
</span>Then we can use the <span class=Inlinecode><span style='font-family:
"Courier New";mso-bidi-font-family:"Times New Roman"'>equal_join</span></span>
operator as following:</p>

<p class=Code>print(</p>

<p class=Code style='text-indent:.5in'>equal_join&lt;mpl::vector&lt;c1&gt;
&gt;(t1, t2)</p>

<p class=Code>);</p>

<p class=MsoNormal><br>
If t2 is <i>not</i> sorted on c2, the best we can do is to use the combination
of <span class=Inlinecode><span style='font-family:"Courier New";mso-bidi-font-family:
"Times New Roman"'>cross_product</span></span> and <span class=Inlinecode><span
style='font-family:"Courier New";mso-bidi-font-family:"Times New Roman"'>selection</span></span>:</p>

<p class=Code>print(</p>

<p class=Code style='text-indent:.5in'>selection(cross_product(t1, t2),
_1[c1()] == _1[c2()])</p>

<p class=Code>);</p>

<h3><a name="_Toc68859962">join_xx</a></h3>

<p class=MsoNormal><span class=Inlinecode><span style='font-family:"Courier New";
mso-bidi-font-family:"Times New Roman"'>join_eq, join_gt, join_lt, join_le,
join_ge</span></span> - all these relations are shortcuts of the range_join
operator that use pre-defined functors. They are binary operators, and require
that their second argument be sorted.<span style="mso-spacerun: yes"> 
</span>They also take a list of fields as template argument. These fields are
extracted from each outer tuple to generate a value that is than used to perform
an appropriate range query on the second argument.</p>

<p class=Code><!--[if supportFields]><span style='mso-element:field-begin'></span><span
style="mso-spacerun: yes"> </span>INCLUDETEXT
&quot;C:\\ark\\checkout\\join_xx.hpp&quot; \c AnsiText<span
style="mso-spacerun: yes">  </span>\* MERGEFORMAT <span style='mso-element:
field-separator'></span><![endif]--><span style='mso-fareast-font-family:"MS Mincho"'>//
Copyright (C) 2002 Dmitriy Arapov, Arkadiy Vertleyb<o:p></o:p></span></p>

<p class=Code><span style='mso-fareast-font-family:"MS Mincho"'>// Permission
to copy, use, modify, sell and distribute this software <o:p></o:p></span></p>

<p class=Code><span style='mso-fareast-font-family:"MS Mincho"'>// is granted
provided this copyright notice appears in all copies. <o:p></o:p></span></p>

<p class=Code><span style='mso-fareast-font-family:"MS Mincho"'>// This
software is provided &quot;as is&quot; without express or implied<o:p></o:p></span></p>

<p class=Code><span style='mso-fareast-font-family:"MS Mincho"'>// warranty,
and with no claim as to its suitability for any purpose.<o:p></o:p></span></p>

<p class=Code><span style='mso-fareast-font-family:"MS Mincho"'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=Code><span style='mso-fareast-font-family:"MS Mincho"'>#ifndef
BOOST_RTL_JOIN_XX_HPP_INCLUDED<o:p></o:p></span></p>

<p class=Code><span style='mso-fareast-font-family:"MS Mincho"'>#define
BOOST_RTL_JOIN_XX_HPP_INCLUDED<o:p></o:p></span></p>

<p class=Code><span style='mso-fareast-font-family:"MS Mincho"'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=Code><span style='mso-fareast-font-family:"MS Mincho"'>#include
&quot;range_join.hpp&quot;<o:p></o:p></span></p>

<p class=Code><span style='mso-fareast-font-family:"MS Mincho"'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=Code><span style='mso-fareast-font-family:"MS Mincho"'>namespace rel<o:p></o:p></span></p>

<p class=Code><span style='mso-fareast-font-family:"MS Mincho"'>{<o:p></o:p></span></p>

<p class=Code><span style='mso-fareast-font-family:"MS Mincho"'><span
style='mso-tab-count:1'>      </span>template&lt;class T1, class T2, class
FieldList&gt;<o:p></o:p></span></p>

<p class=Code><span style='mso-tab-count:1'>      </span><span
style='mso-fareast-font-family:"MS Mincho"'>struct join_eq_t :
equal_join_t&lt;T1, T2, FieldList&gt;<o:p></o:p></span></p>

<p class=Code><span style='mso-fareast-font-family:"MS Mincho"'><span
style='mso-tab-count:1'>      </span>{};<o:p></o:p></span></p>

<p class=Code><span style='mso-fareast-font-family:"MS Mincho"'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=Code><span style='mso-fareast-font-family:"MS Mincho"'><span
style='mso-tab-count:1'>      </span>template&lt;class T1, class T2, class
FieldList&gt;<o:p></o:p></span></p>

<p class=Code><span style='mso-fareast-font-family:"MS Mincho"'><span
style='mso-tab-count:1'>      </span>struct join_lt_t : range_join_t&lt;T1, T2,
begin, lower_bound_t&lt;FieldList&gt; &gt;<o:p></o:p></span></p>

<p class=Code><span style='mso-fareast-font-family:"MS Mincho"'><span
style='mso-tab-count:1'>      </span>{};<o:p></o:p></span></p>

<p class=Code><span style='mso-fareast-font-family:"MS Mincho"'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=Code><span style='mso-fareast-font-family:"MS Mincho"'><span
style='mso-tab-count:1'>      </span>template&lt;class T1, class T2, class
FieldList&gt;<o:p></o:p></span></p>

<p class=Code><span style='mso-fareast-font-family:"MS Mincho"'><span
style='mso-tab-count:1'>      </span>struct join_le_t : range_join_t&lt;T1, T2,
begin, upper_bound_t&lt;FieldList&gt; &gt;<o:p></o:p></span></p>

<p class=Code><span style='mso-fareast-font-family:"MS Mincho"'><span
style='mso-tab-count:1'>      </span>{};<o:p></o:p></span></p>

<p class=Code><span style='mso-fareast-font-family:"MS Mincho"'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=Code><span style='mso-fareast-font-family:"MS Mincho"'><span
style='mso-tab-count:1'>      </span>template&lt;class T1, class T2, class
FieldList&gt;<o:p></o:p></span></p>

<p class=Code><span style='mso-fareast-font-family:"MS Mincho"'><span
style='mso-tab-count:1'>      </span>struct join_gt_t : range_join_t&lt;T1, T2,
upper_bound_t&lt;FieldList&gt;, end&gt;<o:p></o:p></span></p>

<p class=Code><span style='mso-fareast-font-family:"MS Mincho"'><span
style='mso-tab-count:1'>      </span>{};<o:p></o:p></span></p>

<p class=Code><span style='mso-fareast-font-family:"MS Mincho"'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=Code><span style='mso-fareast-font-family:"MS Mincho"'><span
style='mso-tab-count:1'>      </span>template&lt;class T1, class T2, class
FieldList&gt;<o:p></o:p></span></p>

<p class=Code><span style='mso-fareast-font-family:"MS Mincho"'><span
style='mso-tab-count:1'>      </span>struct join_ge_t : range_join_t&lt;T1, T2,
lower_bound_t&lt;FieldList&gt;, end&gt;<o:p></o:p></span></p>

<p class=Code><span style='mso-fareast-font-family:"MS Mincho"'><span
style='mso-tab-count:1'>      </span>{};<o:p></o:p></span></p>

<p class=Code><span style='mso-fareast-font-family:"MS Mincho"'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=Code><span style='mso-fareast-font-family:"MS Mincho"'><span
style='mso-tab-count:1'>      </span>template&lt;class FieldList, class T1,
class T2&gt;<o:p></o:p></span></p>

<p class=Code><span style='mso-fareast-font-family:"MS Mincho"'><span
style='mso-tab-count:2'>            </span>typename join_eq_t&lt;T1, T2,
FieldList&gt;::type <o:p></o:p></span></p>

<p class=Code><span style='mso-fareast-font-family:"MS Mincho"'><span
style='mso-tab-count:2'>            </span>join_eq(const T1&amp; t1, const
T2&amp; t2)<o:p></o:p></span></p>

<p class=Code><span style='mso-fareast-font-family:"MS Mincho"'><span
style='mso-tab-count:1'>      </span>{<o:p></o:p></span></p>

<p class=Code><span style='mso-fareast-font-family:"MS Mincho"'><span
style='mso-tab-count:2'>            </span>return
equal_join&lt;FieldList&gt;(t1, t2);<o:p></o:p></span></p>

<p class=Code><span style='mso-fareast-font-family:"MS Mincho"'><span
style='mso-tab-count:1'>      </span>}<o:p></o:p></span></p>

<p class=Code><span style='mso-fareast-font-family:"MS Mincho"'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=Code><span style='mso-fareast-font-family:"MS Mincho"'><span
style='mso-tab-count:1'>      </span>template&lt;class FieldList, class T1,
class T2&gt;<o:p></o:p></span></p>

<p class=Code><span style='mso-fareast-font-family:"MS Mincho"'><span
style='mso-tab-count:2'>            </span>typename join_lt_t&lt;T1, T2,
FieldList&gt;::type <o:p></o:p></span></p>

<p class=Code><span style='mso-fareast-font-family:"MS Mincho"'><span
style='mso-tab-count:2'>            </span>join_lt(const T1&amp; t1, const
T2&amp; t2)<o:p></o:p></span></p>

<p class=Code><span style='mso-fareast-font-family:"MS Mincho"'><span
style='mso-tab-count:1'>      </span>{<o:p></o:p></span></p>

<p class=Code><span style='mso-fareast-font-family:"MS Mincho"'><span
style='mso-tab-count:2'>            </span>return range_join(t1, t2, begin(),
lower_bound&lt;FieldList&gt;());<o:p></o:p></span></p>

<p class=Code><span style='mso-fareast-font-family:"MS Mincho"'><span
style='mso-tab-count:1'>      </span>}<o:p></o:p></span></p>

<p class=Code><span style='mso-fareast-font-family:"MS Mincho"'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=Code><span style='mso-fareast-font-family:"MS Mincho"'><span
style='mso-tab-count:1'>      </span>template&lt;class FieldList, class T1,
class T2&gt;<o:p></o:p></span></p>

<p class=Code><span style='mso-fareast-font-family:"MS Mincho"'><span
style='mso-tab-count:2'>            </span>typename join_le_t&lt;T1, T2,
FieldList&gt;::type <o:p></o:p></span></p>

<p class=Code><span style='mso-fareast-font-family:"MS Mincho"'><span
style='mso-tab-count:2'>            </span>join_le(const T1&amp; t1, const
T2&amp; t2)<o:p></o:p></span></p>

<p class=Code><span style='mso-fareast-font-family:"MS Mincho"'><span
style='mso-tab-count:1'>      </span>{<o:p></o:p></span></p>

<p class=Code><span style='mso-fareast-font-family:"MS Mincho"'><span
style='mso-tab-count:2'>            </span>return range_join(t1, t2, begin(),
upper_bound&lt;FieldList&gt;());<o:p></o:p></span></p>

<p class=Code><span style='mso-fareast-font-family:"MS Mincho"'><span
style='mso-tab-count:1'>      </span>}<o:p></o:p></span></p>

<p class=Code><span style='mso-fareast-font-family:"MS Mincho"'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=Code><span style='mso-fareast-font-family:"MS Mincho"'><span
style='mso-tab-count:1'>      </span>template&lt;class FieldList, class T1,
class T2&gt;<o:p></o:p></span></p>

<p class=Code><span style='mso-fareast-font-family:"MS Mincho"'><span
style='mso-tab-count:2'>            </span>typename join_gt_t&lt;T1, T2,
FieldList&gt;::type <o:p></o:p></span></p>

<p class=Code><span style='mso-fareast-font-family:"MS Mincho"'><span
style='mso-tab-count:2'>            </span>join_gt(const T1&amp; t1, const
T2&amp; t2)<o:p></o:p></span></p>

<p class=Code><span style='mso-fareast-font-family:"MS Mincho"'><span
style='mso-tab-count:1'>      </span>{<o:p></o:p></span></p>

<p class=Code><span style='mso-fareast-font-family:"MS Mincho"'><span
style='mso-tab-count:2'>            </span>return range_join(t1, t2,
upper_bound&lt;FieldList&gt;(), end());<o:p></o:p></span></p>

<p class=Code><span style='mso-fareast-font-family:"MS Mincho"'><span
style='mso-tab-count:1'>      </span>}<o:p></o:p></span></p>

<p class=Code><span style='mso-fareast-font-family:"MS Mincho"'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=Code><span style='mso-fareast-font-family:"MS Mincho"'><span
style='mso-tab-count:1'>      </span>template&lt;class FieldList, class T1,
class T2&gt;<o:p></o:p></span></p>

<p class=Code><span style='mso-fareast-font-family:"MS Mincho"'><span
style='mso-tab-count:2'>            </span>typename join_ge_t&lt;T1, T2,
FieldList&gt;::type <o:p></o:p></span></p>

<p class=Code><span style='mso-fareast-font-family:"MS Mincho"'><span
style='mso-tab-count:2'>            </span>join_ge(const T1&amp; t1, const
T2&amp; t2)<o:p></o:p></span></p>

<p class=Code><span style='mso-fareast-font-family:"MS Mincho"'><span
style='mso-tab-count:1'>      </span>{<o:p></o:p></span></p>

<p class=Code><span style='mso-tab-count:2'>            </span><span
style='mso-fareast-font-family:"MS Mincho"'>return range_join(t1, t2,
lower_bound&lt;FieldList&gt;(), end());<o:p></o:p></span></p>

<p class=Code><span style='mso-fareast-font-family:"MS Mincho"'><span
style='mso-tab-count:1'>      </span>}<o:p></o:p></span></p>

<p class=Code><span style='mso-fareast-font-family:"MS Mincho"'>}<o:p></o:p></span></p>

<p class=Code><span style='mso-fareast-font-family:"MS Mincho"'>#endif<o:p></o:p></span></p>

<p class=MsoBodyText><!--[if supportFields]><span style='mso-element:field-end'></span><![endif]--><b><br>
</b>Let’s model the following SQL statement:</p>

<p class=Code>select * from t1, t2 where t2.c2 &lt; t1.c1</p>

<p class=MsoNormal><br>
Here is how we can do it with the help of <span class=Inlinecode><span
style='font-family:"Courier New";mso-bidi-font-family:"Times New Roman"'>join_lt</span></span>:</p>

<p class=Code>print(</p>

<p class=Code style='text-indent:.5in'>join_lt&lt;mpl::vector1&lt;c1&gt;
&gt;(t1, t2)</p>

<p class=Code>); // assume t2 is sorted on c2 </p>

<p class=MsoNormal><br>
or without it:</p>

<p class=Code>print(</p>

<p class=Code style='text-indent:.5in'>selection(cross_product(t1, t2),
_1[c2()] &lt; _1[c1()])</p>

<p class=Code>); // assume t2 is not sorted on c2</p>

<h3><a name="_Toc68859963">merge</a></h3>

<p class=MsoNormal>The <span class=Inlinecode><span style='font-family:"Courier New";
mso-bidi-font-family:"Times New Roman"'>join_eq </span></span>relation is very
common, so RTL has another variant of the same relation, which in case when
both operands are sorted the same way works faster (actually it takes
O(count(t1)+count(t2)+count(result)) time). It is called merge. Instead of
FieldList it takes integer PrefixSize as template parameter. It specify prefix
of the sort_list, used for joining relations:</p>

<p class=Code>template&lt;int PrefixSize, class Table1, class Table2&gt; </p>

<p class=Code><span style='mso-tab-count:1'>      </span>merge_t &lt;Table1,
Table2, PrefixSize&gt;::type merge(</p>

<p class=Code><span style='mso-tab-count:2'>            </span>const
Table1&amp; t1,</p>

<p class=Code><span style='mso-tab-count:2'>            </span>const
Table2&amp; t2,</p>

<p class=Code style='text-indent:.5in'>);</p>

<h3><a name="_Toc10048148"></a><a name="_Toc68859964"><span style='mso-bookmark:
_Toc10048148'>rename</span></a></h3>

<p class=MsoNormal>Rename is a unary relation which comes in two flavors: <span
class=Inlinecode><span style='font-family:"Courier New";mso-bidi-font-family:
"Times New Roman"'>auto_raname</span></span> and <span class=Inlinecode><span
style='font-family:"Courier New";mso-bidi-font-family:"Times New Roman"'>manual_raname</span></span>.
The goal of these relational operators is to produce a relation with the same
field values, but different field names. This is important, for example, when
one needs to make a cross_product of a table with itself.<span
style="mso-spacerun: yes">  </span>In addition to its relation argument, <span
class=Inlinecode><span style='font-family:"Courier New";mso-bidi-font-family:
"Times New Roman"'>manual_rename</span></span> operator accepts a list of new
column names (the columns must be previously defined with compatible types):</p>

<p class=Code>template&lt;class FieldList, class Table&gt; </p>

<p class=Code><span style='mso-tab-count:1'>      </span>manual_rename_t&lt;Table,
FieldList&gt;::type manual_rename(const Table&amp; t);</p>

<p class=MsoNormal><br>
Often the new names of columns are irrelevant. Say, they are to be removed by
subsequent projection.<span style="mso-spacerun: yes">  </span>For such
situation the <span class=Inlinecode><span style='font-family:"Courier New";
mso-bidi-font-family:"Times New Roman"'>auto_rename </span></span>relation is
designed:</p>

<p class=Code>template&lt;class Alias, class Table&gt; </p>

<p class=Code style='text-indent:.5in'>auto_rename_t&lt;Table,Alias&gt;::type
auto_rename(const Table&amp; t);</p>

<p class=MsoNormal><b><br>
</b>The <span class=Inlinecode><span style='font-family:"Courier New";
mso-bidi-font-family:"Times New Roman"'>auto_rename</span></span> operator can
be used like this:</p>

<p class=Code>class a; //don’t need to define this</p>

<p class=Code>print(cross_product(t1), auto_rename&lt;a&gt;(t1));</p>

<p class=MsoNormal><br>
The columns are renamed such as, if the alias is “a” and the original name was
“x”, the new name will be <span class=Inlinecode><span style='font-family:"Courier New";
mso-bidi-font-family:"Times New Roman"'>alias&lt;x, a&gt;</span></span>.<span
style="mso-spacerun: yes">  </span>Since the default value of the alias
template parameter is <span class=Inlinecode><span style='font-family:"Courier New";
mso-bidi-font-family:"Times New Roman"'>null_type</span></span>, if this type
is used in the rename function, the new name can be specified as just <span
class=Inlinecode><span style='font-family:"Courier New";mso-bidi-font-family:
"Times New Roman"'>alias&lt;x&gt;</span></span>. </p>

<h3><a name="_Toc68859965">groupby</a></h3>

<p class=MsoNormal>The library provides a unary operator named <span
class=Inlinecode><span style='font-family:"Courier New";mso-bidi-font-family:
"Times New Roman"'>groupby</span></span>.<span style="mso-spacerun: yes"> 
</span>This operator, in addition to its relation argument, accepts two
operands:</p>

<p class=MsoList2 style='mso-list:l1 level1 lfo9;mso-list-change:"%1\:1\:0\:\." "Dmitriy Arapov" 20021020T2133;
tab-stops:list .5in'><![if !supportLists]>1.<span style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
</span><![endif]><span class=Inlinecode><span style='font-family:"Courier New";
mso-bidi-font-family:"Times New Roman"'>PrefixSize</span></span> stands for the
number of columns from sort_list of base relation to use for grouping. </p>

<p class=MsoNormal style='margin-left:.5in;text-indent:-.25in;mso-list:l1 level1 lfo9;
mso-list-change:"%1\:2\:0\:\." "Dmitriy Arapov" 20021020T2133;tab-stops:list .5in'><![if !supportLists]>2.<span
style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span><![endif]><span
class=Inlinecode><span style='font-family:"Courier New";mso-bidi-font-family:
"Times New Roman"'>GroupList</span></span> is the list of aggregating functors.
There are bunch of such functors designed for use with the <span
class=Inlinecode><span style='font-family:"Courier New";mso-bidi-font-family:
"Times New Roman"'>groupby</span></span> operator. </p>

<p class=Code>template&lt;class KeyList, class GroupList, class Table&gt; </p>

<p class=Code style='text-indent:.5in'>groupby_t&lt;Table,KeyList,GroupList&gt;::type
groupby(const Table&amp; t);</p>

<p class=MsoNormal><br>
The <span class=Inlinecode><span style='font-family:"Courier New";mso-bidi-font-family:
"Times New Roman"'>groupby</span></span> operator can be used like this:</p>

<p class=Code>table&lt;table_info&lt;mpl::vector2&lt;c1, c2&gt; &gt; &gt; tab;</p>

<p class=Code>. . .</p>

<p class=Code>typedef mpl::vector3&lt;sum&lt;c2&gt;, counter, min&lt;c2&gt;
&gt; group_list;</p>

<p class=Code>print(groupby&lt;1, group_list&gt;(tab));</p>

<p class=MsoBodyText><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></p>

<p class=MsoBodyText>RTL provides a number of pre-defined functors to be used
in group_lists: <span class=Inlinecode><span style='font-family:"Courier New";
mso-bidi-font-family:"Times New Roman"'>sum</span></span>, <span
class=Inlinecode><span style='font-family:"Courier New";mso-bidi-font-family:
"Times New Roman"'>counter</span></span>, <span class=Inlinecode><span
style='font-family:"Courier New";mso-bidi-font-family:"Times New Roman"'>min</span></span>,
<span class=Inlinecode><span style='font-family:"Courier New";mso-bidi-font-family:
"Times New Roman"'>max</span></span>. </p>

<h1><a name="_Toc68859966">Indexes</a></h1>

<p class=MsoNormal>Indexes allow to access data from other relations in
different order.<span style="mso-spacerun: yes">  </span>RTL provides two
variant of indexes: <span class=Inlinecode><span style='font-family:"Courier New";
mso-bidi-font-family:"Times New Roman"'>iterator_index</span></span> and <span
class=Inlinecode><span style='font-family:"Courier New";mso-bidi-font-family:
"Times New Roman"'>key_index</span></span>.<span style="mso-spacerun: yes"> 
</span>Both take a relation and new <span class=Inlinecode><span
style='font-family:"Courier New";mso-bidi-font-family:"Times New Roman"'>SortList</span></span>
as template parameters. They have to store new order, and internally use a
table for this purpose. To allow different implementations user can specify <span
class=Inlinecode><span style='font-family:"Courier New";mso-bidi-font-family:
"Times New Roman"'>Strategy</span></span>, which codes the table
implementation.</p>

<p class=Code>template&lt;class SortList, class Table&gt; </p>

<p class=Code><span style="mso-spacerun: yes"> </span><span style='mso-tab-count:
1'>     </span>iterator_index_t&lt;Table,SortList&gt;::type
iterator_index(const Table&amp; t);</p>

<p class=MsoNormal><br>
<span class=Inlinecode><span style='font-family:"Courier New";mso-bidi-font-family:
"Times New Roman"'>Iterator_index</span></span> holds all fields from the <span
class=Inlinecode><span style='font-family:"Courier New";mso-bidi-font-family:
"Times New Roman"'>SortList</span></span> and the iterator of the base
relation. </p>

<p class=MsoNormal><span class=Inlinecode><span style='font-family:"Courier New";
mso-bidi-font-family:"Times New Roman"'>key_index</span></span> is quite
similar, but instead of storing iterators, it keeps a sort_list (primary key)
of the base relation.</p>

<p class=Code>template&lt;class SortList, class Table&gt; </p>

<p class=Code><span style="mso-spacerun: yes"> </span><span style='mso-tab-count:
1'>     </span>key_index_t&lt;Table,SortList&gt;::type key_index(const
Table&amp; t);</p>

<h1><a name="_Toc68859967">Invert</a></h1>

<p class=MsoNormal>Sometimes it is not good to use indexes, because of the
overhead they impose. In such cases it is better to keep two independent copies
of a table, each of them sorted different way. Function invert serves this
purpose. Note, there is no such class, just function, which creates ordinary
table with given sort order. As usual, it is possible to specify the
implementation to use, it can be different for the source table and inverted
table:</p>

<p class=Code>template&lt;class SortList, class Strategy, class Table&gt;<br>
table</p>

<p class=Code>&lt;</p>

<p class=Code><span style='mso-tab-count:1'>      </span>table_info</p>

<p class=Code><span style='mso-tab-count:1'>      </span>&lt;</p>

<p class=Code><span style='mso-tab-count:2'>            </span>typename
Table::field_list,</p>

<p class=Code><span style='mso-tab-count:2'>            </span>SortList,</p>

<p class=Code><span style='mso-tab-count:2'>            </span>Typename
Table::keys,</p>

<p class=Code><span style='mso-tab-count:2'>            </span>Strategy</p>

<p class=Code><span style='mso-tab-count:1'>      </span>&gt;</p>

<p class=Code>&gt;</p>

<p class=Code>invert (const Table&amp; t);</p>

<h1><a name="_Toc68859968">Let the compiler figure it out</a></h1>

<p class=MsoNormal>Let’s consider the expression from the “example” section:</p>

<p class=Code>projection&lt;column_list&gt;(</p>

<p class=Code><span style="mso-spacerun: yes">  </span>selection(</p>

<p class=Code><span style="mso-spacerun: yes">    </span>cross_product(t,
rename&lt;null_type&gt;(t)),</p>

<p class=Code><span style="mso-spacerun: yes">   
</span>distance_less_than(1)))<span style="mso-spacerun: yes">  </span></p>

<p class=MsoNormal><br>
What is the type of this expression?<span style="mso-spacerun: yes"> 
</span>The type is important if you want to assign the expression to some
intermediate variable.<span style="mso-spacerun: yes">  </span>Unfortunately
the type is rather complicated, and does not exactly benefit the readability of
your application:</p>

<p class=Code>auto_rename_t&lt;</p>

<p class=Code><span style='mso-tab-count:1'>      </span>table_t, </p>

<p class=Code><span style='mso-tab-count:1'>      </span>null_type&gt;::type
rename_result(t); </p>

<p class=Code><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></p>

<p class=Code>cross_product_t&lt;</p>

<p class=Code><span style='mso-tab-count:1'>      </span>table_t,</p>

<p class=Code><span style='mso-tab-count:1'>      </span>auto_rename_t&lt;</p>

<p class=Code><span style='mso-tab-count:2'>            </span>table_t, </p>

<p class=Code><span style='mso-tab-count:2'>            </span>null_type&gt;::type&gt;::type
cross_product_result(t, rename_result); </p>

<p class=Code><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></p>

<p class=Code>distance_less_than pred(1);</p>

<p class=Code><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></p>

<p class=Code>selection_t&lt;</p>

<p class=Code><span style='mso-tab-count:1'>      </span>cross_product_t&lt;</p>

<p class=Code><span style='mso-tab-count:2'>            </span>table_t,</p>

<p class=Code><span style='mso-tab-count:2'>            </span>auto_rename_t&lt;</p>

<p class=Code><span style='mso-tab-count:3'>                  </span>table_t, </p>

<p class=Code><span style='mso-tab-count:3'>                  </span>null_type&gt;::type&gt;::type,
</p>

<p class=Code><span style='mso-tab-count:3'>                  </span>distance_less_than&gt;::type
selection_result(cross_product_result, pred); </p>

<p class=Code><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></p>

<p class=Code>typedef</p>

<p class=Code><span style='mso-tab-count:1'>      </span>projection_t&lt;</p>

<p class=Code><span style='mso-tab-count:2'>            </span>selection_t&lt;</p>

<p class=Code><span style='mso-tab-count:3'>                  </span>cross_product_t&lt;</p>

<p class=Code><span style='mso-tab-count:4'>                        </span>table_t,</p>

<p class=Code><span style='mso-tab-count:4'>                        </span>auto_rename_t&lt;</p>

<p class=Code><span style='mso-tab-count:5'>                              </span>table_t,
</p>

<p class=Code><span style='mso-tab-count:5'>                              </span>null_type&gt;::type&gt;::type,
</p>

<p class=Code><span style='mso-tab-count:3'>                  </span>distance_less_than&gt;::type,
</p>

<p class=Code><span style='mso-tab-count:3'>                  </span>column_list&gt;::type
result_type;</p>

<p class=Code><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></p>

<p class=Code>result_type result(selection_result);</p>

<p class=Code><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></p>

<p class=Code>for (result_type::const_iterator i = result.begin(); i !=
result.end(); ++i)</p>

<p class=Code>{</p>

<p class=Code><span style='mso-tab-count:1'>      </span>result_type::value_type
tup = *i;</p>

<p class=Code><span style='mso-tab-count:1'>      </span>cout<span
style="mso-spacerun: yes">  </span>&lt;&lt; FIELD(tup, name) &lt;&lt;
FIELD(tup, alias&lt;name&gt;) &lt;&lt; endl; </p>

<p class=Code>}</p>

<p class=MsoNormal><br>
This can be simplified with a few intermediate typedefs, but still wouldn’t
look pretty, would it?</p>

<p class=MsoNormal>The methods to deal with such problem are described in the
“techniques” section of [3].<span style="mso-spacerun: yes">  </span>One<span
style="mso-spacerun: yes">  </span>method involves letting the compiler
generate the error message, and copy-paste the type from that message.<span
style="mso-spacerun: yes">  </span>The ultimate solution would be to use the <span
class=Inlinecode><span style='font-family:"Courier New";mso-bidi-font-family:
"Times New Roman"'>typeof</span></span> operator.<span style="mso-spacerun:
yes">  </span>However, at this point, the <span class=Inlinecode><span
style='font-family:"Courier New";mso-bidi-font-family:"Times New Roman"'>typeof</span></span>
operator is not in the C++ standard, and is not supported by most compilers.</p>

<p class=MsoNormal>Fortunately, in some cases, you don’t have to care about the
type of the expression.<span style="mso-spacerun: yes">  </span>All that is
important is that this is some sort of relation that can be iterated through,
used in STL algorithms, or supplied as an input to a relational operator.<span
style="mso-spacerun: yes">  </span>Another important thing is what fields are
present in the tuple.</p>

<p class=MsoNormal>Let the compiler take care about the details.<span
style="mso-spacerun: yes">  </span>Just define a template function
parameterized with a table type, and pass the result of the expression to this
function:</p>

<p class=Code>template &lt;class Table&gt; void prettyprint(const Table&amp; t)</p>

<p class=Code>{</p>

<p class=Code><span style="mso-spacerun: yes">  </span>for
(Table::const_iterator i = t.begin(); i != t.end(); ++i)</p>

<p class=Code><span style="mso-spacerun: yes">  </span>{</p>

<p class=Code><span style="mso-spacerun: yes">    </span>Table::tuple tup = *i;</p>

<p class=Code><span style="mso-spacerun: yes">    </span>cout &lt;&lt; left
&lt;&lt; setw(20) &lt;&lt; FIELD(tup, name) &lt;&lt; FIELD(tup,
alias&lt;name&gt;) &lt;&lt; endl; </p>

<p class=Code><span style="mso-spacerun: yes">  </span>}</p>

<p class=Code>}</p>

<p class=Code>. . .</p>

<p class=Code>prettyprint(</p>

<p class=Code><span style="mso-spacerun: yes"> 
</span>projection&lt;column_list&gt;(</p>

<p class=Code><span style="mso-spacerun: yes">    </span>selection(</p>

<p class=Code><span style="mso-spacerun: yes">      </span>cross_product(t,
rename&lt;null_type&gt;(t)),</p>

<p class=Code><span style="mso-spacerun: yes">      </span>distance_less_than(1)));</p>

<h1><a name="_Toc68859969">Transactions</a></h1>

<p class=MsoNormal style='margin-bottom:0in;margin-bottom:.0001pt;mso-layout-grid-align:
none;text-autospace:none'><span style='mso-bidi-font-size:10.0pt;mso-bidi-font-family:
Arial'>The main purpose of transactions is to synchronize multiple updates to
one or more table(s). If a transaction is committed all updates are applied. If
the transaction is rolled back, all updates are discarded. The other usual
purpose is to provide synchronization between threads. RTL doesn't address the
synchronization issue at this point. This is an orthogonal issue, and can be
addressed with the Boost thread library.<o:p></o:p></span></p>

<p class=MsoNormal style='margin-bottom:0in;margin-bottom:.0001pt;mso-layout-grid-align:
none;text-autospace:none'><span style='mso-bidi-font-size:10.0pt;mso-bidi-font-family:
Arial'><span style="mso-spacerun: yes"> </span><o:p></o:p></span></p>

<p class=MsoNormal style='margin-bottom:0in;margin-bottom:.0001pt;mso-layout-grid-align:
none;text-autospace:none'><span style='mso-bidi-font-size:10.0pt;mso-bidi-font-family:
Arial'>Transactions also provide a convenient point for updating those
relational expressions that depend on tables being changed. RTL uses this to
perform incremental update of some nodes in the expression, and full
reset/rebuild of the others -- ones for which incremental updates can't be
applied. Incremental updates may save a lot of time, especially when changes
are relatively small, and relations deal with large amount of data. <o:p></o:p></span></p>

<h2><a name="_Toc60203354"></a><a name="_Toc68859970"><span style='mso-bookmark:
_Toc60203354'>Delta</span>s for tables</a></h2>

<p class=MsoNormal style='margin-bottom:0in;margin-bottom:.0001pt;mso-layout-grid-align:
none;text-autospace:none'><span style='mso-bidi-font-size:10.0pt;mso-bidi-font-family:
Arial'>RTL uses pessimistic approach to transactions. That means that, when a
table is modified through a transaction, the changes are not applied
immediately. While the table remains unchanged, the changes go into something
we call &quot;delta&quot;.<o:p></o:p></span></p>

<p class=MsoNormal style='margin-bottom:0in;margin-bottom:.0001pt;mso-layout-grid-align:
none;text-autospace:none'><span style='mso-bidi-font-size:10.0pt;mso-bidi-font-family:
Arial'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=MsoNormal style='margin-bottom:0in;margin-bottom:.0001pt;mso-layout-grid-align:
none;text-autospace:none'><span style='mso-bidi-font-size:10.0pt;mso-bidi-font-family:
Arial'>In RTL, delta is a pair of relations. One relation is a table, and
serves to hold inserted tuples.<span style="mso-spacerun: yes">  </span>We call
this table a &quot;plus&quot;.<span style="mso-spacerun: yes">  </span>Another
relation is kind of an index into the table being modified, and contains
iterators to all removed tuples.<span style="mso-spacerun: yes">  </span>We
call this relation a &quot;minus&quot;.<span style="mso-spacerun: yes"> 
</span>Any update is represented by a pair insert/remove (this is optimized to
just perform an in-place update when the transaction is committed, provided
that the key part of a tuple remained unchanged).<o:p></o:p></span></p>

<p class=MsoNormal style='margin-bottom:0in;margin-bottom:.0001pt;mso-layout-grid-align:
none;text-autospace:none'><span style='mso-bidi-font-size:10.0pt;mso-bidi-font-family:
Arial'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=MsoNormal style='margin-bottom:0in;margin-bottom:.0001pt;mso-layout-grid-align:
none;text-autospace:none'><span style='mso-bidi-font-size:10.0pt;mso-bidi-font-family:
Arial'>To manage the deltas the &quot;transaction&quot; object is used.<span
style="mso-spacerun: yes">  </span>This object contains exactly one delta (plus
and minus) for each table being modified through this transaction.<span
style="mso-spacerun: yes">  </span>If the transaction is committed, all the
deltas are applied.<span style="mso-spacerun: yes">  </span>If the transaction
is rolled back, or the transaction object is destroyed, all the deltas get
discarded.<o:p></o:p></span></p>

<p class=MsoNormal style='margin-bottom:0in;margin-bottom:.0001pt;mso-layout-grid-align:
none;text-autospace:none'><span style='mso-bidi-font-size:10.0pt;mso-bidi-font-family:
Arial'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=MsoNormal style='margin-bottom:0in;margin-bottom:.0001pt;mso-layout-grid-align:
none;text-autospace:none'><span style='mso-bidi-font-size:10.0pt;mso-bidi-font-family:
Arial'>As was mentioned above, the table stays the same until the transaction
is committed.<span style="mso-spacerun: yes">  </span>During that time, the
modified view of a table can be obtained through the </span><span
class=Inlinecode><span style='font-family:"Courier New";mso-bidi-font-family:
"Times New Roman"'>modified</span></span><span style='mso-bidi-font-size:10.0pt;
mso-bidi-font-family:Arial'> namespace-scoped function:<o:p></o:p></span></p>

<p class=MsoNormal style='margin-bottom:0in;margin-bottom:.0001pt;mso-layout-grid-align:
none;text-autospace:none'><span style='font-size:10.0pt;mso-bidi-font-family:
Arial'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=Code>print(modified(table, transaction));<span style="mso-spacerun:
yes">  </span></p>

<h2><a name="_Toc68859971">Incremental index update</a></h2>

<p class=MsoNormal style='margin-bottom:0in;margin-bottom:.0001pt;mso-layout-grid-align:
none;text-autospace:none'><span style='mso-bidi-font-size:10.0pt;mso-bidi-font-family:
Arial'>Now the fun begins: for any relational operator we also can calculate
its delta. The delta can is a function (relational expression) of its still
unchanged arguments and deltas of those arguments. Applying this statement recursively,
we can state that:<o:p></o:p></span></p>

<p class=MsoNormal style='margin-bottom:0in;margin-bottom:.0001pt;mso-layout-grid-align:
none;text-autospace:none'><span style='mso-bidi-font-size:10.0pt;mso-bidi-font-family:
Arial'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=MsoNormal style='margin-bottom:0in;margin-bottom:.0001pt;mso-layout-grid-align:
none;text-autospace:none'><i><span style='mso-bidi-font-size:10.0pt;mso-bidi-font-family:
Arial'>For any arbitrary complicated relation its delta can be calculated,
given the transaction object.<o:p></o:p></span></i></p>

<p class=MsoNormal style='margin-bottom:0in;margin-bottom:.0001pt;mso-layout-grid-align:
none;text-autospace:none'><span style='mso-bidi-font-size:10.0pt;mso-bidi-font-family:
Arial'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=MsoNormal style='margin-bottom:0in;margin-bottom:.0001pt;mso-layout-grid-align:
none;text-autospace:none'><span style='mso-bidi-font-size:10.0pt;mso-bidi-font-family:
Arial'>For given transaction and a relation we can see modifications made as
two relations:<o:p></o:p></span></p>

<p class=MsoNormal style='margin-bottom:0in;margin-bottom:.0001pt;mso-layout-grid-align:
none;text-autospace:none'><span style='mso-bidi-font-size:10.0pt;mso-bidi-font-family:
Arial'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=Code>print(delta(expr, trans).second); // data removed</p>

<p class=Code>print(delta(expr, trans).first); // data added</p>

<p class=MsoNormal style='margin-bottom:0in;margin-bottom:.0001pt;mso-layout-grid-align:
none;text-autospace:none'><span style='mso-bidi-font-size:10.0pt;mso-bidi-font-family:
Arial'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=MsoNormal style='margin-bottom:0in;margin-bottom:.0001pt;mso-layout-grid-align:
none;text-autospace:none'><span style='mso-bidi-font-size:10.0pt;mso-bidi-font-family:
Arial'>Or, its modified view can be obtained:<o:p></o:p></span></p>

<p class=MsoNormal style='margin-bottom:0in;margin-bottom:.0001pt;mso-layout-grid-align:
none;text-autospace:none'><span style='font-size:10.0pt;mso-bidi-font-family:
Arial'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=Code>print(modified(expr, trans));</p>

<p class=MsoNormal style='margin-bottom:0in;margin-bottom:.0001pt;mso-layout-grid-align:
none;text-autospace:none'><span style='font-size:10.0pt;mso-bidi-font-family:
Arial'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=MsoNormal style='margin-bottom:0in;margin-bottom:.0001pt;mso-layout-grid-align:
none;text-autospace:none'><span style='mso-bidi-font-size:10.0pt;mso-bidi-font-family:
Arial'>A typical relational expression is rather complicated, and can contain
quite a few indexes dependant on modified tables and on each other.<span
style="mso-spacerun: yes">  </span>The example below will use an employee table
sorted by employee ID.<span style="mso-spacerun: yes">  </span>To get the task
done, the example will use a key index to sort employees by </span><span
class=Inlinecode><span style='font-family:"Courier New";mso-bidi-font-family:
"Times New Roman"'>joined</span></span><span style='mso-bidi-font-size:10.0pt;
mso-bidi-font-family:Arial'> date, get a range of such employees, and use
another key index to sort this range by name.<o:p></o:p></span></p>

<p class=MsoNormal style='margin-bottom:0in;margin-bottom:.0001pt;mso-layout-grid-align:
none;text-autospace:none'><span style='mso-bidi-font-size:10.0pt;mso-bidi-font-family:
Arial'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=MsoNormal style='margin-bottom:0in;margin-bottom:.0001pt;mso-layout-grid-align:
none;text-autospace:none'><span style='mso-bidi-font-size:10.0pt;mso-bidi-font-family:
Arial'>When an employee is added to such a system, two indexes mentioned above
become invalidated.<span style="mso-spacerun: yes">  </span>If we want to
perform the query again, we'd rather rebuild indexes.<o:p></o:p></span></p>

<p class=MsoNormal style='margin-bottom:0in;margin-bottom:.0001pt;mso-layout-grid-align:
none;text-autospace:none'><span style='mso-bidi-font-size:10.0pt;mso-bidi-font-family:
Arial'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=MsoNormal style='margin-bottom:0in;margin-bottom:.0001pt;mso-layout-grid-align:
none;text-autospace:none'><span style='mso-bidi-font-size:10.0pt;mso-bidi-font-family:
Arial'>However, with RTL this is not the case:<o:p></o:p></span></p>

<p class=MsoNormal style='margin-bottom:0in;margin-bottom:.0001pt;mso-layout-grid-align:
none;text-autospace:none'><span style='mso-bidi-font-size:10.0pt;mso-bidi-font-family:
Arial'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=MsoNormal style='margin-bottom:0in;margin-bottom:.0001pt;mso-layout-grid-align:
none;text-autospace:none'><i><span style='mso-bidi-font-size:10.0pt;mso-bidi-font-family:
Arial'>Rather than fully rebuild two indexes, RTL will use indexes' deltas to
just insert one tuple into one of them, and (maybe) one tuple into another one.
<o:p></o:p></span></i></p>

<p class=MsoNormal style='margin-bottom:0in;margin-bottom:.0001pt;mso-layout-grid-align:
none;text-autospace:none'><span style='mso-bidi-font-size:10.0pt;mso-bidi-font-family:
Arial'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=MsoNormal style='margin-bottom:0in;margin-bottom:.0001pt;mso-layout-grid-align:
none;text-autospace:none'><span style='mso-bidi-font-size:10.0pt;mso-bidi-font-family:
Arial'>The performance benefit can be huge, depending on the amount of data,
complexity of the expression, and the nature of objects used for keys.<span
style="mso-spacerun: yes">  </span>It will also depend on a table
implementation used with indexes.<span style="mso-spacerun: yes">  </span>The
indexes build on some form of set have high cost of rebuild, and low cost of
insert/remove.<span style="mso-spacerun: yes">  </span>Such indexes will
benefit more than ones build on a sorted </span><span class=Inlinecode><span
style='font-family:"Courier New";mso-bidi-font-family:"Times New Roman"'>std::vector</span></span><span
style='mso-bidi-font-size:10.0pt;mso-bidi-font-family:Arial'>, where the cost
of full reallocation is lower, and cost of single insert/remove is higher. <o:p></o:p></span></p>

<h2><a name="_Toc68859972">Full reset/rebuild</a></h2>

<p class=MsoNormal style='margin-bottom:0in;margin-bottom:.0001pt;mso-layout-grid-align:
none;text-autospace:none'><span style='mso-bidi-font-size:10.0pt;mso-bidi-font-family:
Arial'>Not everything can be updated incrementally.<span style="mso-spacerun:
yes">  </span>One example is iterator indexes.<span style="mso-spacerun: yes"> 
</span>Since iterators are invalidated when tables get modified, so are the
iterator indexes.<span style="mso-spacerun: yes">  </span>RTL will still
rebuild the indexes for you, but you will not gain the performance benefit as
you would with the key indexes.<span style="mso-spacerun: yes">  </span>Since
iterator indexes are generally faster than key indexes, this is a trade-off
(there are quite a few factors one should consider when choosing between
iterator and key indexes -- this deserves a separate discussion).<span
style="mso-spacerun: yes">   </span><o:p></o:p></span></p>

<h2><a name="_Toc68859973">Example</a></h2>

<p class=MsoNormal>The following example demonstrates how to modify tables
through a transaction, and how expressions get incrementally updated.</p>

<p class=Code><!--[if supportFields]><span style='mso-element:field-begin'></span><span
style="mso-spacerun: yes"> </span>INCLUDETEXT
&quot;.\\transactions_sample.cpp&quot; \c AnsiText<span style="mso-spacerun:
yes">  </span>\* MERGEFORMAT <span style='mso-element:field-separator'></span><![endif]--><span
style='mso-fareast-font-family:"MS Mincho"'>// transactions example<o:p></o:p></span></p>

<p class=Code><span style='mso-fareast-font-family:"MS Mincho"'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=Code><span style='mso-fareast-font-family:"MS Mincho"'>#include
&quot;table_delta.hpp&quot;<o:p></o:p></span></p>

<p class=Code><span style='mso-fareast-font-family:"MS Mincho"'>#include
&quot;key_index_delta.hpp&quot;<o:p></o:p></span></p>

<p class=Code><span style='mso-fareast-font-family:"MS Mincho"'>#include
&quot;range_selection_delta.hpp&quot;<o:p></o:p></span></p>

<p class=Code><span style='mso-fareast-font-family:"MS Mincho"'>#include
&quot;transaction.hpp&quot;<o:p></o:p></span></p>

<p class=Code><span style='mso-fareast-font-family:"MS Mincho"'>#include
&quot;utils.hpp&quot;<o:p></o:p></span></p>

<p class=Code><span style='mso-fareast-font-family:"MS Mincho"'>#include
&quot;expression_registry.hpp&quot;<o:p></o:p></span></p>

<p class=Code><span style='mso-fareast-font-family:"MS Mincho"'>#include
&lt;boost/date_time/gregorian/greg_date.hpp&gt;<o:p></o:p></span></p>

<p class=Code><span style='mso-fareast-font-family:"MS Mincho"'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=Code><span style='mso-fareast-font-family:"MS Mincho"'>using namespace
std;<o:p></o:p></span></p>

<p class=Code><span style='mso-fareast-font-family:"MS Mincho"'>using namespace
boost;<o:p></o:p></span></p>

<p class=Code><span style='mso-fareast-font-family:"MS Mincho"'>using namespace
gregorian;<o:p></o:p></span></p>

<p class=Code><span style='mso-fareast-font-family:"MS Mincho"'>using namespace
rel;<o:p></o:p></span></p>

<p class=Code><span style='mso-fareast-font-family:"MS Mincho"'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=Code><span style='mso-fareast-font-family:"MS Mincho"'>// Since
default constructor is not provided<o:p></o:p></span></p>

<p class=Code><span style='mso-fareast-font-family:"MS Mincho"'>// for
gregorian::date, we need to define its default value<o:p></o:p></span></p>

<p class=Code><span style='mso-fareast-font-family:"MS Mincho"'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=Code><span style='mso-fareast-font-family:"MS Mincho"'>namespace rel<o:p></o:p></span></p>

<p class=Code><span style='mso-fareast-font-family:"MS Mincho"'>{<o:p></o:p></span></p>

<p class=Code><span style='mso-fareast-font-family:"MS Mincho"'><span
style='mso-tab-count:1'>      </span>template&lt;&gt;<o:p></o:p></span></p>

<p class=Code><span style='mso-fareast-font-family:"MS Mincho"'><span
style='mso-tab-count:2'>            </span>struct default_value&lt;date&gt;<o:p></o:p></span></p>

<p class=Code><span style='mso-fareast-font-family:"MS Mincho"'><span
style='mso-tab-count:1'>      </span>{<o:p></o:p></span></p>

<p class=Code><span style='mso-fareast-font-family:"MS Mincho"'><span
style='mso-tab-count:2'>            </span>static date get()<o:p></o:p></span></p>

<p class=Code><span style='mso-fareast-font-family:"MS Mincho"'><span
style='mso-tab-count:2'>            </span>{<o:p></o:p></span></p>

<p class=Code><span style='mso-fareast-font-family:"MS Mincho"'><span
style='mso-tab-count:3'>                  </span>return date(1980, Jan, 1);<o:p></o:p></span></p>

<p class=Code><span style='mso-fareast-font-family:"MS Mincho"'><span
style='mso-tab-count:2'>            </span>}<o:p></o:p></span></p>

<p class=Code><span style='mso-fareast-font-family:"MS Mincho"'><span
style='mso-tab-count:1'>      </span>};<o:p></o:p></span></p>

<p class=Code><span style='mso-fareast-font-family:"MS Mincho"'>}<o:p></o:p></span></p>

<p class=Code><span style='mso-fareast-font-family:"MS Mincho"'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=Code><span style='mso-fareast-font-family:"MS Mincho"'>//
operator&lt;&lt;() is only needed to be able to use the print() utility<o:p></o:p></span></p>

<p class=Code><span style='mso-fareast-font-family:"MS Mincho"'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=Code><span style='mso-fareast-font-family:"MS Mincho"'>ostream&amp;
operator&lt;&lt;(ostream&amp; s, const date&amp; d)<o:p></o:p></span></p>

<p class=Code><span style='mso-fareast-font-family:"MS Mincho"'>{<o:p></o:p></span></p>

<p class=Code><span style='mso-fareast-font-family:"MS Mincho"'><span
style='mso-tab-count:1'>      </span>s &lt;&lt; d.month() &lt;&lt;
&quot;/&quot; &lt;&lt; d.day()<span style="mso-spacerun: yes">  </span>&lt;&lt;
&quot;/&quot; &lt;&lt; d.year();<o:p></o:p></span></p>

<p class=Code><span style='mso-fareast-font-family:"MS Mincho"'><span
style='mso-tab-count:1'>      </span>return s;<o:p></o:p></span></p>

<p class=Code><span style='mso-fareast-font-family:"MS Mincho"'>}<o:p></o:p></span></p>

<p class=Code><span style='mso-fareast-font-family:"MS Mincho"'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=Code><span style='mso-fareast-font-family:"MS Mincho"'>// define
columns, table, and tuple types<o:p></o:p></span></p>

<p class=Code><span style='mso-fareast-font-family:"MS Mincho"'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=Code><span style='mso-fareast-font-family:"MS Mincho"'>BOOST_RTL_DEFINE_COLUMN(int,
id);<o:p></o:p></span></p>

<p class=Code><span style='mso-fareast-font-family:"MS Mincho"'>BOOST_RTL_DEFINE_COLUMN(string,
name);<o:p></o:p></span></p>

<p class=Code><span style='mso-fareast-font-family:"MS Mincho"'>BOOST_RTL_DEFINE_COLUMN(date,
joined);<o:p></o:p></span></p>

<p class=Code><span style='mso-fareast-font-family:"MS Mincho"'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=Code><span style='mso-fareast-font-family:"MS Mincho"'>struct employee_info
: table_info&lt;<o:p></o:p></span></p>

<p class=Code><span style='mso-fareast-font-family:"MS Mincho"'><span
style='mso-tab-count:1'>      </span>mpl::vector&lt;id, name, joined&gt;, <o:p></o:p></span></p>

<p class=Code><span style='mso-fareast-font-family:"MS Mincho"'><span
style='mso-tab-count:1'>      </span>mpl::vector&lt;id&gt; <o:p></o:p></span></p>

<p class=Code><span style='mso-fareast-font-family:"MS Mincho"'><span
style='mso-tab-count:1'>      </span>&gt; {};<o:p></o:p></span></p>

<p class=Code><span style='mso-fareast-font-family:"MS Mincho"'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=Code><span style='mso-fareast-font-family:"MS Mincho"'>typedef
table&lt;employee_info&gt; employee_table;<o:p></o:p></span></p>

<p class=Code><span style='mso-fareast-font-family:"MS Mincho"'>typedef
table&lt;employee_info&gt;::value_type employee_tuple;<o:p></o:p></span></p>

<p class=Code><span style='mso-fareast-font-family:"MS Mincho"'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=Code><span style='mso-fareast-font-family:"MS Mincho"'>// This
relational expression is used to query <o:p></o:p></span></p>

<p class=Code><span style='mso-fareast-font-family:"MS Mincho"'>// for all people
joined between given dates,<o:p></o:p></span></p>

<p class=Code><span style='mso-fareast-font-family:"MS Mincho"'>// and sort
them by name<o:p></o:p></span></p>

<p class=Code><span style='mso-fareast-font-family:"MS Mincho"'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=Code><span style='mso-fareast-font-family:"MS Mincho"'>typedef
key_index_t&lt;<o:p></o:p></span></p>

<p class=Code><span style='mso-fareast-font-family:"MS Mincho"'><span
style='mso-tab-count:1'>      </span>range_selection_t&lt;<o:p></o:p></span></p>

<p class=Code><span style='mso-fareast-font-family:"MS Mincho"'><span
style='mso-tab-count:2'>            </span>key_index_t&lt;employee_table,
mpl::vector&lt;joined, id&gt; &gt;::type, <o:p></o:p></span></p>

<p class=Code><span style='mso-fareast-font-family:"MS Mincho"'><span
style='mso-tab-count:2'>            </span>lower_bound_t&lt;row&lt;mpl::vector&lt;joined&gt;
&gt; &gt;, <o:p></o:p></span></p>

<p class=Code><span style='mso-fareast-font-family:"MS Mincho"'><span
style='mso-tab-count:2'>            </span>lower_bound_t&lt;row&lt;mpl::vector&lt;joined&gt;
&gt; &gt; <o:p></o:p></span></p>

<p class=Code><span style='mso-fareast-font-family:"MS Mincho"'><span
style='mso-tab-count:2'>            </span>&gt;::type, <o:p></o:p></span></p>

<p class=Code><span style='mso-fareast-font-family:"MS Mincho"'><span
style='mso-tab-count:1'>      </span>mpl::vector&lt;name, id&gt; <o:p></o:p></span></p>

<p class=Code><span style='mso-fareast-font-family:"MS Mincho"'><span
style='mso-tab-count:1'>      </span>&gt;::type expr_type;<o:p></o:p></span></p>

<p class=Code><span style='mso-fareast-font-family:"MS Mincho"'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=Code><span style='mso-fareast-font-family:"MS Mincho"'>main()<o:p></o:p></span></p>

<p class=Code><span style='mso-fareast-font-family:"MS Mincho"'>{<o:p></o:p></span></p>

<p class=Code><span style='mso-fareast-font-family:"MS Mincho"'><span
style='mso-tab-count:1'>      </span>//allocate and populate the table (without
using transactions)<o:p></o:p></span></p>

<p class=Code><span style='mso-fareast-font-family:"MS Mincho"'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=Code><span style='mso-fareast-font-family:"MS Mincho"'><span
style='mso-tab-count:1'>      </span>table&lt;employee_info&gt; t;<o:p></o:p></span></p>

<p class=Code><span style='mso-fareast-font-family:"MS Mincho"'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=Code><span style='mso-fareast-font-family:"MS Mincho"'><span
style='mso-tab-count:1'>      </span>t.insert(employee_tuple(1, &quot;A&quot;,
date(2003, Dec, 7)));<o:p></o:p></span></p>

<p class=Code><span style='mso-fareast-font-family:"MS Mincho"'><span
style='mso-tab-count:1'>      </span>t.insert(employee_tuple(2, &quot;B&quot;,
date(2003, Dec, 10)));<o:p></o:p></span></p>

<p class=Code><span style='mso-fareast-font-family:"MS Mincho"'><span
style='mso-tab-count:1'>      </span>t.insert(employee_tuple(3, &quot;C&quot;,
date(2003, Dec, 5)));<o:p></o:p></span></p>

<p class=Code><span style='mso-fareast-font-family:"MS Mincho"'><span
style='mso-tab-count:1'>      </span>t.insert(employee_tuple(4, &quot;D&quot;,
date(2003, Dec, 2)));<o:p></o:p></span></p>

<p class=Code><span style='mso-fareast-font-family:"MS Mincho"'><span
style='mso-tab-count:1'>      </span>t.insert(employee_tuple(5, &quot;E&quot;,
date(2003, Dec, 13)));<o:p></o:p></span></p>

<p class=Code><span style='mso-fareast-font-family:"MS Mincho"'><span
style='mso-tab-count:1'>      </span>t.insert(employee_tuple(6, &quot;F&quot;,
date(2003, Dec, 25)));<o:p></o:p></span></p>

<p class=Code><span style='mso-fareast-font-family:"MS Mincho"'><span
style='mso-tab-count:1'>      </span>t.insert(employee_tuple(7, &quot;G&quot;,
date(2003, Dec, 13)));<o:p></o:p></span></p>

<p class=Code><span style='mso-fareast-font-family:"MS Mincho"'><span
style='mso-tab-count:1'>      </span>t.insert(employee_tuple(8, &quot;H&quot;,
date(2003, Dec, 24)));<o:p></o:p></span></p>

<p class=Code><span style='mso-fareast-font-family:"MS Mincho"'><span
style='mso-tab-count:1'>      </span>t.insert(employee_tuple(9, &quot;I&quot;,
date(2003, Dec, 30)));<o:p></o:p></span></p>

<p class=Code><span style='mso-fareast-font-family:"MS Mincho"'><span
style='mso-tab-count:1'>      </span>t.insert(employee_tuple(10, &quot;J&quot;,
date(2003, Dec, 1)));<o:p></o:p></span></p>

<p class=Code><span style='mso-fareast-font-family:"MS Mincho"'><span
style='mso-tab-count:1'>      </span><o:p></o:p></span></p>

<p class=Code><span style='mso-fareast-font-family:"MS Mincho"'><span
style='mso-tab-count:1'>      </span>// allocate the expression to query for
people joined <o:p></o:p></span></p>

<p class=Code><span style='mso-fareast-font-family:"MS Mincho"'><span
style='mso-tab-count:1'>      </span>// between 12/5/2003 and 12/25/2003, and
sort them by name<o:p></o:p></span></p>

<p class=Code><span style='mso-fareast-font-family:"MS Mincho"'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=Code><span style='mso-fareast-font-family:"MS Mincho"'><span
style='mso-tab-count:1'>      </span>expr_type expr =
key_index&lt;mpl::vector&lt;name, id&gt; &gt;(<o:p></o:p></span></p>

<p class=Code><span style='mso-fareast-font-family:"MS Mincho"'><span
style='mso-tab-count:2'>            </span>range_selection(<o:p></o:p></span></p>

<p class=Code><span style='mso-fareast-font-family:"MS Mincho"'><span
style='mso-tab-count:3'>                  </span>key_index&lt;mpl::vector&lt;joined,
id&gt; &gt;(t),<o:p></o:p></span></p>

<p class=Code><span style='mso-fareast-font-family:"MS Mincho"'><span
style='mso-tab-count:3'>                  </span>lower_bound(row&lt;mpl::vector&lt;joined&gt;
&gt;(date(2003, Dec, 5))), <o:p></o:p></span></p>

<p class=Code><span style='mso-fareast-font-family:"MS Mincho"'><span
style='mso-tab-count:3'>                  </span>lower_bound(row&lt;mpl::vector&lt;joined&gt;
&gt;(date(2003, Dec, 25))) <o:p></o:p></span></p>

<p class=Code><span style='mso-fareast-font-family:"MS Mincho"'><span
style='mso-tab-count:2'>            </span>)<o:p></o:p></span></p>

<p class=Code><span style='mso-fareast-font-family:"MS Mincho"'><span
style='mso-tab-count:1'>      </span>);<o:p></o:p></span></p>

<p class=Code><span style='mso-fareast-font-family:"MS Mincho"'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=Code><span style='mso-fareast-font-family:"MS Mincho"'><span
style='mso-tab-count:1'>      </span>// run the query<o:p></o:p></span></p>

<p class=Code><span style='mso-fareast-font-family:"MS Mincho"'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=Code><span style='mso-fareast-font-family:"MS Mincho"'><span
style='mso-tab-count:1'>      </span>print(expr);<o:p></o:p></span></p>

<p class=Code><span style='mso-fareast-font-family:"MS Mincho"'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=Code><span style='mso-fareast-font-family:"MS Mincho"'><span
style='mso-tab-count:1'>      </span>// allocate the transaction object<o:p></o:p></span></p>

<p class=Code><span style='mso-fareast-font-family:"MS Mincho"'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=Code><span style='mso-fareast-font-family:"MS Mincho"'><span
style='mso-tab-count:1'>      </span>transaction tr;<o:p></o:p></span></p>

<p class=Code><span style='mso-fareast-font-family:"MS Mincho"'><span
style='mso-tab-count:1'>      </span><o:p></o:p></span></p>

<p class=Code><span style='mso-fareast-font-family:"MS Mincho"'><span
style='mso-tab-count:1'>      </span>// modify the table through the
transaction<o:p></o:p></span></p>

<p class=Code><span style='mso-fareast-font-family:"MS Mincho"'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=Code><span style='mso-fareast-font-family:"MS Mincho"'><span
style='mso-tab-count:1'>      </span>tr.insert(t, employee_tuple(11,
&quot;K&quot;, date(2003, Dec, 7)));<o:p></o:p></span></p>

<p class=Code><span style='mso-fareast-font-family:"MS Mincho"'><span
style='mso-tab-count:1'>      </span>tr.insert(t, employee_tuple(12,
&quot;CC&quot;, date(2003, Dec, 17)));<o:p></o:p></span></p>

<p class=Code><span style='mso-fareast-font-family:"MS Mincho"'><span
style='mso-tab-count:1'>      </span>tr.remove(t,
*t.lower_bound(row&lt;mpl::vector&lt;id&gt; &gt;(5)));<o:p></o:p></span></p>

<p class=Code><span style='mso-fareast-font-family:"MS Mincho"'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=Code><span style='mso-fareast-font-family:"MS Mincho"'><span
style='mso-tab-count:1'>      </span>// create the list of expressions to be
updated at commit<o:p></o:p></span></p>

<p class=Code><span style='mso-fareast-font-family:"MS Mincho"'><span
style='mso-tab-count:1'>      </span>// in this example we have only one
expression<o:p></o:p></span></p>

<p class=Code><span style='mso-fareast-font-family:"MS Mincho"'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=Code><span style='mso-fareast-font-family:"MS Mincho"'><span
style='mso-tab-count:1'>      </span>expression_registry exprs;<o:p></o:p></span></p>

<p class=Code><span style='mso-fareast-font-family:"MS Mincho"'><span
style='mso-tab-count:1'>      </span>exprs.add(expr);<o:p></o:p></span></p>

<p class=Code><span style='mso-fareast-font-family:"MS Mincho"'><span
style='mso-tab-count:1'>      </span><o:p></o:p></span></p>

<p class=Code><span style='mso-fareast-font-family:"MS Mincho"'><span
style='mso-tab-count:1'>      </span>// commit the transaction.<span
style="mso-spacerun: yes">  </span>Tell it to update the expression.<o:p></o:p></span></p>

<p class=Code><span style='mso-fareast-font-family:"MS Mincho"'><span
style='mso-tab-count:1'>      </span>// two indexes get incrementally updated
rather than rebuilt.<o:p></o:p></span></p>

<p class=Code><span style='mso-fareast-font-family:"MS Mincho"'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=Code><span style='mso-fareast-font-family:"MS Mincho"'><span
style='mso-tab-count:1'>      </span>tr.commit(exprs);<o:p></o:p></span></p>

<p class=Code><span style='mso-fareast-font-family:"MS Mincho"'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=Code><span style='mso-fareast-font-family:"MS Mincho"'><span
style='mso-tab-count:1'>      </span>// reuse the query<o:p></o:p></span></p>

<p class=Code><span style='mso-fareast-font-family:"MS Mincho"'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=Code><span style='mso-fareast-font-family:"MS Mincho"'><span
style='mso-tab-count:1'>      </span>print(expr);<o:p></o:p></span></p>

<p class=Code><span style='mso-fareast-font-family:"MS Mincho"'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=Code><span style='mso-fareast-font-family:"MS Mincho"'><span
style='mso-tab-count:1'>      </span>return 0;<o:p></o:p></span></p>

<p class=Code><span style='mso-fareast-font-family:"MS Mincho"'>}<o:p></o:p></span></p>

<p class=Code><!--[if supportFields]><span style='mso-element:field-end'></span><![endif]--><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></p>

<h2><a name="_Toc68859974">Reference</a></h2>

<h3><a name="_Toc68859975">transaction</a></h3>

<p class=MsoNormal>Transaction is used to store tables’ deltas.<span
style="mso-spacerun: yes">  </span>At commit, the deltas are applied.<span
style="mso-spacerun: yes">  </span>Also, at commit, the expressions specified
by the user are updated.</p>

<p class=Code>template&lt;class Exprs&gt; void commit(Exprs&amp; exprs);</p>

<p class=Code>void commit();</p>

<p class=MsoNormal style='margin-bottom:0in;margin-bottom:.0001pt;mso-layout-grid-align:
none;text-autospace:none'><span style='font-size:10.0pt;mso-bidi-font-family:
Arial'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=MsoNormal style='margin-bottom:0in;margin-bottom:.0001pt;mso-layout-grid-align:
none;text-autospace:none'><span style='mso-bidi-font-size:10.0pt;mso-bidi-font-family:
Arial'>The first function commits the transaction and updates the expressions
supplied in </span><span class=Inlinecode><span style='font-family:"Courier New";
mso-bidi-font-family:"Times New Roman"'>exprs</span></span><span
style='mso-bidi-font-size:10.0pt;mso-bidi-font-family:Arial'>.<span
style="mso-spacerun: yes">  </span></span><span class=Inlinecode><span
style='font-family:"Courier New";mso-bidi-font-family:"Times New Roman"'>Exprs</span></span><span
style='mso-bidi-font-size:10.0pt;mso-bidi-font-family:Arial'> is normally an
instance of the </span><span class=Inlinecode><span style='font-family:"Courier New";
mso-bidi-font-family:"Times New Roman"'>expression_registry</span></span><span
style='mso-bidi-font-size:10.0pt;mso-bidi-font-family:Arial'> class.<o:p></o:p></span></p>

<p class=MsoNormal style='margin-bottom:0in;margin-bottom:.0001pt;mso-layout-grid-align:
none;text-autospace:none'><span style='mso-bidi-font-size:10.0pt;mso-bidi-font-family:
Arial'><span style="mso-spacerun: yes"> </span><o:p></o:p></span></p>

<p class=Code>void rollback();</p>

<p class=MsoNormal style='margin-bottom:0in;margin-bottom:.0001pt;mso-layout-grid-align:
none;text-autospace:none'><span style='mso-bidi-font-size:10.0pt;mso-bidi-font-family:
Arial'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=MsoNormal style='margin-bottom:0in;margin-bottom:.0001pt;mso-layout-grid-align:
none;text-autospace:none'><span style='mso-bidi-font-size:10.0pt;mso-bidi-font-family:
Arial'>Rolls back the transaction.<span style="mso-spacerun: yes">  </span>All
deltas are discarded.<o:p></o:p></span></p>

<p class=MsoNormal style='margin-bottom:0in;margin-bottom:.0001pt;mso-layout-grid-align:
none;text-autospace:none'><span style='mso-bidi-font-size:10.0pt;mso-bidi-font-family:
Arial'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=Code>template&lt;class Info&gt; </p>

<p class=Code><span style='mso-tab-count:1'>      </span>bool insert(const
table&lt;Info&gt;&amp; t, const typename table&lt;Info&gt;::value_type&amp;
tuple);</p>

<p class=MsoNormal style='margin-bottom:0in;margin-bottom:.0001pt;mso-layout-grid-align:
none;text-autospace:none'><span style='mso-bidi-font-size:10.0pt;mso-bidi-font-family:
Arial'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=MsoNormal style='margin-bottom:0in;margin-bottom:.0001pt;mso-layout-grid-align:
none;text-autospace:none'><span style='mso-bidi-font-size:10.0pt;mso-bidi-font-family:
Arial'>Inserts the tuple into the table.<span style="mso-spacerun: yes"> 
</span>The changes are applied to the table delta rather than the table itself.<o:p></o:p></span></p>

<p class=MsoNormal style='margin-bottom:0in;margin-bottom:.0001pt;mso-layout-grid-align:
none;text-autospace:none'><span style='mso-bidi-font-size:10.0pt;mso-bidi-font-family:
Arial'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=Code>template&lt;class Info&gt;</p>

<p class=Code><span style='mso-tab-count:1'>      </span>bool remove(const
table&lt;Info&gt;&amp; t, const typename table&lt;Info&gt;::value_type&amp;
tuple);</p>

<p class=Code>template&lt;class Info&gt;</p>

<p class=Code><span style='mso-tab-count:1'>      </span>bool remove(const
typename table&lt;Info&gt;::const_iterator&amp; it);</p>

<p class=MsoNormal style='margin-bottom:0in;margin-bottom:.0001pt;mso-layout-grid-align:
none;text-autospace:none'><span style='mso-bidi-font-size:10.0pt;mso-bidi-font-family:
Arial'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=MsoNormal style='margin-bottom:0in;margin-bottom:.0001pt;mso-layout-grid-align:
none;text-autospace:none'><span style='mso-bidi-font-size:10.0pt;mso-bidi-font-family:
Arial'>Removes the tuple from the table.<span style="mso-spacerun: yes"> 
</span>The changes are applied to the table delta rather than the table itself.<o:p></o:p></span></p>

<p class=MsoNormal style='margin-bottom:0in;margin-bottom:.0001pt;mso-layout-grid-align:
none;text-autospace:none'><span style='mso-bidi-font-size:10.0pt;mso-bidi-font-family:
Arial'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=Code>template&lt;class Info&gt;</p>

<p class=Code><span style='mso-tab-count:1'>      </span>bool update(const
table&lt;Info&gt;&amp; t, const typename table&lt;Info&gt;::value_type&amp;
tuple);</p>

<p class=Code>template&lt;class Info&gt;</p>

<p class=Code><span style='mso-tab-count:1'>      </span>bool update(const
typename table&lt;Info&gt;::const_iterator&amp; it, const typename
table&lt;Info&gt;::value_type&amp; tuple);</p>

<p class=MsoNormal style='margin-bottom:0in;margin-bottom:.0001pt;mso-layout-grid-align:
none;text-autospace:none'><span style='mso-bidi-font-size:10.0pt;mso-bidi-font-family:
Arial'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=MsoNormal style='margin-bottom:0in;margin-bottom:.0001pt;mso-layout-grid-align:
none;text-autospace:none'><span style='mso-bidi-font-size:10.0pt;mso-bidi-font-family:
Arial'>Updates the tuple.<span style="mso-spacerun: yes">  </span>The changes
are applied to the table delta rather than the table itself.<o:p></o:p></span></p>

<h3><a name="_Toc68859976">expression_registry</a></h3>

<p class=MsoNormal>Expression registry is used to store the relational
expressions, and update them at commit.<span style="mso-spacerun: yes"> 
</span>The update process is done in two phases, one run immediately before the
transaction commits the table deltas, and another – immediately after that.</p>

<p class=Code>template&lt;class E&gt; void add(const E&amp; exp);</p>

<p class=MsoNormal><br>
Adds the expression to the registry.</p>

<h3><a name="_Toc68859977">delta</a></h3>

<p class=MsoNormal style='margin-bottom:0in;margin-bottom:.0001pt;mso-layout-grid-align:
none;text-autospace:none'><span style='mso-bidi-font-size:10.0pt;mso-bidi-font-family:
Arial'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=Code>template&lt;class R&gt; </p>

<p class=Code style='text-indent:.5in'>typename traits&lt;R&gt;::delta_type
delta(const R&amp; r, const transaction&amp; tr);</p>

<p class=MsoNormal style='margin-bottom:0in;margin-bottom:.0001pt;mso-layout-grid-align:
none;text-autospace:none'><span style='mso-bidi-font-size:10.0pt;mso-bidi-font-family:
Arial'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=MsoNormal style='margin-bottom:0in;margin-bottom:.0001pt;mso-layout-grid-align:
none;text-autospace:none'><span style='mso-bidi-font-size:10.0pt;mso-bidi-font-family:
Arial'>This namespace-scoped function returns the delta of a given
relation.<span style="mso-spacerun: yes">  </span>The delta is an </span><span
class=Inlinecode><span style='font-family:"Courier New";mso-bidi-font-family:
"Times New Roman"'>std::pair</span></span><span style='mso-bidi-font-size:10.0pt;
mso-bidi-font-family:Arial'> of relations, where </span><span class=Inlinecode><span
style='font-family:"Courier New";mso-bidi-font-family:"Times New Roman"'>first</span></span><span
style='mso-bidi-font-size:10.0pt;mso-bidi-font-family:Arial'> is a plus and </span><span
class=Inlinecode><span style='font-family:"Courier New";mso-bidi-font-family:
"Times New Roman"'>second</span></span><span style='mso-bidi-font-size:10.0pt;
mso-bidi-font-family:Arial'> is a minus.<o:p></o:p></span></p>

<h3><a name="_Toc68859978">modified</a></h3>

<p class=MsoNormal style='margin-bottom:0in;margin-bottom:.0001pt;mso-layout-grid-align:
none;text-autospace:none'><span style='mso-bidi-font-size:10.0pt;mso-bidi-font-family:
Arial'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=Code>template&lt;class R&gt;</p>

<p class=Code><span style='mso-tab-count:1'>      </span>typename
traits&lt;R&gt;::modified_type modified(const R&amp; r, const transaction&amp;
tr);</p>

<p class=MsoBodyText><br>
<span style='mso-bidi-font-size:10.0pt;mso-bidi-font-family:Arial'>This
namespace-scoped function returns the modified view of a given relation.</span></p>

<h1><a name="_Toc68859979">Tests</a></h1>

<p class=MsoNormal>The “test” directory contains set of simple tests, which can
serve as additional examples on how to use the system.<span
style="mso-spacerun: yes">  </span>The tests have essential advantage of being
guaranteed to always be up-to-date.<span style="mso-spacerun: yes"> 
</span>This text doesn’t.<span style="mso-spacerun: yes">    </span></p>

<h1><a name="_Toc68859980">Compilers</a></h1>

<p class=MsoNormal>Initially RTL was developed with MSVC 6.0 compiler. However,
it has significant limitations: limited size of identifiers, which leads to
“duplicate comdat” problem, limitation on the size of template tree, which can
cause calling wrong function during execution, early template instantiation
bug, limitation on overall complexity of one module, which leads to “internal
structure overflow” error message and mysterious “internal compiler error”. We
tried to keep test working with this compiler, but can’t recommend it for any
real work with the library. We also ported library to VC++.Net 2003 and found
no problem there and gcc 3.3.1.<span style="mso-spacerun: yes">  </span>In both
cases compilation goes smoothly, but requires lot of memory and compilation
time.</p>

<h1><a name="_Toc68859981">Bibliography</a></h1>

<p class=MsoNormal>[1] Andrei Alexandrescu<span style="mso-spacerun: yes"> 
</span>“Modern C++ Design: generic programming and design patterns applied”,
2001, Addison-Wesley.</p>

<p class=MsoNormal>[2] Martin Gruber “Understanding SQL”, 1990, Sybex Inc.</p>

<p class=MsoNormal>[3] Joel de Guzman et al “Spirit v1.8.0 User's Guide”, 2003,
<a href="http://www.boost.org/libs/spirit/index.html">http://www.boost.org/libs/spirit/index.html</a></p>

<p class=MsoNormal><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></p>

<p class=MsoNormal><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></p>

</div>

</body>

</html>
