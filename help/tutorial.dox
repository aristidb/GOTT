/**
@page tutorial Tutorial

@section tut_start Getting started

Let's start quickly. We must test whether the compiler actually works
decently! We do this by testing whether 1 is actually the same as 1.

@code
#include <testsoon.hpp>

TEST(compiler_check) {
  Equals(1, 1); // let's hope it works!!
}

TEST_REGISTRY;

int main() {
  testsoon::default_reporter rep;
  testsoon::tests().run(rep);
}
@endcode

In order to compile this ... important test, you first need to make sure that
a recent testsoon.hpp is in your include path. It can be found in the
include/ directory of the distribution. You may just copy it into your
project folder. No other installation is required.

If you compile and run this program, you should see something like this on
your console:
@verbatim
"simple.cpp" : .

1 tests, 1 succeeded, 0 failed.
@endverbatim

I guess this means that we can trust our compiler a little bit. Or so it
seems. Seriously, this is our first successful test. Let me explain what
the code above actually means. I shall do this by thoroughly commenting
the code.

@code
// You really can guess why we do this.
#include <testsoon.hpp>

// Declare a simple test with name "compiler_check". Note that no quotes are
// required here.
TEST(compiler_check) {
  // Check whether the two numbers are equal.
  Equals(1, 1);
}

// This line is required _once_ per executable. It ensures that if the code
// compiles, everything works smoothly. The principle here: no surprises.
TEST_REGISTRY;

int main() {
  // Declare a reporter. The default_reporter should be a sensible setting.
  // That's why it's the default.
  testsoon::default_reporter rep;

  // Run all tests.
  testsoon::tests().run(rep);
}
@endcode

So now let's play around and test something different: are 1 and 2 equal?
Change the check as follows:

@code
Equals(1, 2);
@endcode

Now, the output should look like something like this:

@verbatim
"simple.cpp" : [F=3.4]

Error occured in test "compiler_check" in "simple.cpp" on line 3 in check on line 4.
Problem: not equal: 1 and 2
Data:
        1
        2

1 tests, 0 succeeded, 1 failed.
@endverbatim

Obviously, both numbers differ. Lets look at the first strange thing:
"[F=3.4]". This little thing means that there was a failure in the test on
line 3 (simple.cpp), to be exact the check on line 4 failed. (I used the
version without comments.)

The same information is represented below and with additional information.
"Data" are the two parameter values to Equals. This is necessary because
in other situations the "problem" might not be "not equal: 1 and 2" but
"not equal: a and b" where a and b are variables. In this case, "data" would
contain the values of both variables in (readable) string representation.

@section tut_checks Standard checks

TODO

@section tut_grouping Grouping

@subsection tut_autogroup Automatic grouping

Test soon supports automatic grouping by file name. You can place tests
in any source file and the source file will automatically make up a group.
You do not need to manually add a group for the file. Nor do you need to
add a macro or some strange code somewhere in your file.

In most circumstances you will structure a test executable like this:
-# A runner executable containing \c #TEST_REGISTRY; and \c main().
-# A hierarchy of test sources.

@subsection tut_mangroup Manual grouping

Named tests are nice, of course. And grouping by files is practical, too.
However, you might want to group tests deeper. Or you might be to lazy to
create a new file for this new test group. Do not despair!

@code
TEST_GROUP(group_one) {
  TEST() {
    Check(!"unnamed test in group_one");
  }

  TEST(named) {
    Check(!"named test in group_one");
  }
}

TEST_GROUP(group_two) {
  TEST() {
    Check(!"only test in group_two");
  }
  TEST_GROUP(nested) {
    TEST() {
      Check(!"except if you count this test in a nested group");
    }
  }
}
@endcode

The Checks will all fail because they are passed a false value. \c ! applied
to a non-null pointer value is always \c false.

\note "Test soon" uses namespaces for grouping, so your group names must
valid namespace names.

@section tut_ext_syntax Extended syntax

You already saw that you can define tests with the TEST macro. But there
also is an alternative syntax which you can use, too. It has advantages
that will become evident later.

@code
XTEST() {} // unnamed test
XTEST((name, "my test")) {} // named test
XTEST((n, "my other test")) {} // a named test, too
XTEST((parameter1_name, parameter1_value) (parameter2_name, parameter2_value))
  // illegal but demonstrates how to use multiple parameters
@endcode

#XTEST enables you to use named parameters. Some parameters have short and
long names, like name, alias n. This syntax does not make much sense so far,
but you will see how it is useful later.

@section tut_fixtures Fixtures

@subsection tut_explicit_fixtures Explicit fixtures

TODO

@subsection tut_group_fixtures Group fixtures

TODO

@section tut_generators Generators

TODO
*/
