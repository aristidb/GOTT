/**
@page german_tutorial Tutorial(German)

@section los_gehts Los geht's!

Fangen wir gleich mit dem ersten Code an, der uns den aufschlussreichen Test
bietet, ob 1 denn gleich 1 ist:

@code
#include <testsoon.hpp>

TEST(compiler_check) {
  Equals(1, 1); // Hoffen wir das Beste
}

TEST_REGISTRY;

int main() {
  testsoon::default_reporter rep;
  testsoon::tests().run(rep);
}
@endcode

\b ACHTUNG: Testsoon benoetigt Boost um zu kompilieren!


Nach dem Kompilieren und ausfuehren des Programms, sollte es folgendes ausgeben:
@verbatim
"simple.cpp" : .

1 tests, 1 succeeded, 0 failed.
@endverbatim

Wenn dem so ist, so arbeitet der Compiler vermutlich richtig mit Testsoon zusammen.


@section erste_schritte Erste Schritte mit Testsoon

Jetzt ist man sicherlich auch daran interressiert, was der Code, den man jetzt
brav kopiert hat ueberhaupt tut. Dazu nochmal der Code von oben, komplett kommentiert:

@code
// Wenn diese Zeile nicht verstanden wird, sollte man sich (noch)einmal mit C++
// vertraut machen...
#include <testsoon.hpp>

// Hier wird ein Test mit Namen "compiler_check" erstellt. Es ist wichtig, dass 
// er nicht(!) gequoted wird.
TEST(compiler_check) {
  // Check whether the two numbers are equal.
  Equals(1, 1);
}

// Diese Zeile muss in jedem Projekt, das Testsoon benutzt genau einmal vorkommen.
// Sie ist sozusagen der "Anlasser" fuer Tetsoon. (Wo diese Zeile geschrieben wird,
// ist egal, solange sie im Projekt bleibt)
TEST_REGISTRY;

int main() {
  // Hier wird eine Instanz eines Reporters erstellt. Wir verwenden den 
  // "default_reporter".
  testsoon::default_reporter rep;

  // Testsoon fuehrt durch das Aufrufen dieser Funktion alle erstellten Tests durch.
  // Uebergeben wird eine Instanz eines Reporters.
  testsoon::tests().run(rep);
}
@endcode

Moment! Wenn Testsoon so gemuetlich ist, warum muss man dann noch muehsam einen Reporter
erstellen und diesen an \c testsoon::tests().run() uebergeben?
Obwohl Testsoon sehr auf "Gemuetlichkeit" gegruendet ist, so sollten die Moeglichkeiten
nicht darunter leiden.
Moechte man zum Beispiel neben der Ausgabe des default_reporters noch eine andere
Ausgabe haben, so kann man eine Instanz eines weiteren Reporters erstellen und diese an
\c testsoon::tests().run() uebergeben.


\b Uebrigens: Testsoon bietet ein selbsterklaerendes Reporter Interface, durch welches
	die Moeglichkeit besteht auch leicht selbst einen an den eigenen Beduerfnissen
	angepassten Reporter zu schreiben. Hierrauf komme ich spaeter im Tutorial
	zurueck.


@subsection standard_checks Standard Checks

Jetzt wollen wir es etwas interessanter werden lassen. Was passiert, wenn man Testsoon
einen Test ausfuehren laesst, der nicht mit \c true abschliesst?

Dazu ersetzen wir ersteinmal die Zeile

@code
Equals(1, 1);
@endcode

durch

@code
Equals(1, 2);
@endcode

Danach kompilieren wir das Projekt erneut und fuehren das Programm aus.
Die Ausgabe sollte danach der folgenden aehnlich sein.

@verbatim
"simple.cpp" : [F=3.4]

Error occured in test "compiler_check" in "simple.cpp" on line 3 in check on line 4.
Problem: not equal: 1 and 2
Data:
        1
        2

1 tests, 0 succeeded, 1 failed.
@endverbatim

Die erste Auffaelligkeit ist wohl, dass der einfache Punkt durch \c [F=3.4] ersetzt wurde.
Beides sind Symbole die den Testverlauf eines Tests angeben, wobei der einfache Punkt fuer
einen erfolgreichen, \c [F=3.4] fuer einen fehlgeschlagenen Test steht. Nebenbei zeigt 
\c [F=3.4] , dass ein Test in der Zeile 4 fehlschlug, der zum ab der 3. Zeile deklarierten
Testblock gehoert. Am Ende einer jeden Ausgabe stehen nocheinmal praezisere Informationen zu
dem fehlgeschlagenen Test. Dort findet man neben einer kurzen Beschreibung des Problems
auch die "rohen" uebergebenen Daten. Hier waren es zum Beispiel "1" und "2".


@subsection autogrouping Automatische Gruppenerstellung

Dem aufmerksamen Leser mag vielleicht aufgefallen sein, dass ich vorhin \c "simple.cpp"
in der Testsoonausgabe uebergangen habe. Es zeigt, dass die nachfolgenden Punkte bzw.
[F=...]-Konstrukte zu der \e Gruppe \c simple.cpp gehoeren. Fuer die naechste Sektion ist
zu beachten, dass Testsoon automatisch fuer jede Datei, die Tests enthaelt, eine Gruppe
erstellt und diese nach dem Dateinamen benennt.

@subsection grouping Manuelle Gruppenerstellung

Natuerlich ist das Erstellen neuer Gruppe nicht gleichbedeutend mit dem Erstellen neuer
Dateien. Es ist mit Hilfe des Makros \c TEST_GROUP(name) moeglich neue Gruppen zu 
erstellen. Diese neuen Gruppen werden der "Datei-Gruppe" (hier \c simple.cpp )
untergeordnet.

@code
TEST_GROUP(Gruppe_Eins) {
  TEST() {
    Check(!"unbenannter Test in \"Gruppe_Eins\"");
  }

  TEST(Benannt) {
    Check(!"Test \"Benannt\" in \"Gruppe_Eins\"");
  }
}

TEST_GROUP(Gruppe_Zwei) {
  TEST() {
    Check(!"Ein Test in \"Gruppe_Zwei\"");
  }
  TEST_GROUP(Gruppe_Zwei_Eins) {
    TEST() {
      Check(!"Ein Test von \"Gruppe_Zwei_Eins\", die zu \"Gruppe_Zwei\" gehoert");
    }
  }
}
@endcode

Nach dem Einfuegen in zum Beispiel \c simple.cpp, Kompilieren und erneutem Ausfuehren,
sollten diese vier Tests fehlschlagen. (Wenn nicht klar sein sollte warum, achtet auf
das "!" vor dem Check. Wie wir (hoffentlich) wissen negiert "!" einen booleschen Wert,
sodass jeder nicht- \c false Wert zu eben diesem wird.)
Der Name einer Gruppe wird ebenfalls nicht in Anfuehrungszeichen gesetzt. Testsoon
arbeitet intern mit "namespaces", um die Gruppen zu erstellen.

@subsection ext_syntax "Extended Syntax"

TO-DO
**/
